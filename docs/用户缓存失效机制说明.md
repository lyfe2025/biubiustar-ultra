# 用户缓存失效机制说明文档

## 📋 概述

用户缓存失效机制是一个智能的、统一的缓存管理系统，确保当用户数据发生变化时，相关的缓存能够被正确和及时地清理或更新，维护数据一致性。

## 🏗️ 系统架构

### 核心组件

1. **UserCacheInvalidationService** - 主服务类
2. **UserCacheInvalidationType** - 失效类型枚举
3. **便捷函数** - 快速调用的便捷方法
4. **测试API** - 开发环境下的测试接口

### 技术栈

- **基础缓存**: EnhancedCacheService (6个实例)
- **失效引擎**: CacheInvalidationService
- **失效策略**: 模式匹配 + 依赖关系
- **执行方式**: 同步失效 + 延迟失效

## 🎯 失效类型和策略

### 失效类型 (UserCacheInvalidationType)

| 类型 | 描述 | 影响范围 | 执行策略 |
|------|------|----------|----------|
| `CREATE` | 用户创建 | 列表缓存 + 统计缓存 | 立即失效 |
| `UPDATE` | 用户更新 | 用户详情 + API缓存 | 立即失效 |
| `DELETE` | 用户删除 | 该用户所有缓存 | 立即失效 |
| `BATCH_DELETE` | 批量删除 | 多个用户的所有缓存 | 并行失效 |
| `STATUS_CHANGE` | 状态变更 | 用户详情 + 会话缓存 | 立即失效 |
| `ROLE_CHANGE` | 角色变更 | 用户详情 + 权限缓存 | 立即失效 |
| `PROFILE_UPDATE` | 资料更新 | 用户详情 + API缓存 | 立即失效 |

### 缓存实例映射

| 缓存实例 | 用途 | 失效触发条件 |
|----------|------|-------------|
| `userCache` | 用户列表、详情 | 所有用户操作 |
| `statsCache` | 用户统计数据 | 用户数量变化 |
| `apiCache` | API响应缓存 | 用户相关API调用 |
| `sessionCache` | 会话、权限缓存 | 状态/角色变更 |

## 🔧 使用方法

### 1. 便捷函数（推荐）

```typescript
import { 
  invalidateOnUserCreate,
  invalidateOnUserUpdate,
  invalidateOnUserDelete,
  invalidateOnBatchUserDelete,
  invalidateOnUserStatusChange,
  invalidateOnUserRoleChange
} from '../utils/userCacheInvalidation.js';

// 用户创建后
await invalidateOnUserCreate();

// 用户更新后
await invalidateOnUserUpdate(userId);

// 用户删除后
await invalidateOnUserDelete(userId);

// 批量用户删除后
await invalidateOnBatchUserDelete(userIds);

// 用户状态变更后
await invalidateOnUserStatusChange(userId);

// 用户角色变更后
await invalidateOnUserRoleChange(userId);
```

### 2. 服务类直接调用

```typescript
import { userCacheInvalidationService, UserCacheInvalidationType } from '../utils/userCacheInvalidation.js';

// 自定义失效选项
const results = await userCacheInvalidationService.invalidate({
  type: UserCacheInvalidationType.UPDATE,
  userId: 'user123',
  invalidateStats: true,
  invalidateList: true,
  delay: 1000, // 延迟1秒
  additionalPatterns: ['custom:pattern:*']
});
```

## 📊 性能特性

### 执行性能

- **并行失效**: 多个缓存实例并行处理
- **模式匹配**: 高效的键模式匹配算法
- **批量操作**: 支持批量用户的缓存失效
- **延迟失效**: 非关键缓存的延迟清理

### 失效精度

- **精确失效**: 只失效相关的缓存键
- **依赖失效**: 自动处理缓存间的依赖关系
- **智能分类**: 根据操作类型选择合适的失效范围

### 错误处理

- **容错设计**: 单个失效失败不影响其他操作
- **详细日志**: 完整的失效过程日志记录
- **结果报告**: 详细的失效结果统计

## 🧪 测试和验证

### 开发环境测试API

**基础URL**: `/api/cache-invalidation-test`

#### 1. 获取失效服务状态
```bash
GET /api/cache-invalidation-test/status
```

#### 2. 手动触发用户创建失效
```bash
POST /api/cache-invalidation-test/user/create
```

#### 3. 手动触发用户更新失效
```bash
POST /api/cache-invalidation-test/user/update/{userId}
```

#### 4. 手动触发用户删除失效
```bash
POST /api/cache-invalidation-test/user/delete/{userId}
```

#### 5. 批量缓存失效测试
```bash
POST /api/cache-invalidation-test/user/batch
Content-Type: application/json

{
  "userIds": ["user1", "user2", "user3"],
  "type": "delete" // 或 "update"
}
```

#### 6. 自定义缓存失效测试
```bash
POST /api/cache-invalidation-test/custom
Content-Type: application/json

{
  "type": "UPDATE",
  "userId": "user123",
  "invalidateStats": true,
  "invalidateList": true,
  "delay": 1000,
  "additionalPatterns": ["custom:*"]
}
```

### 测试结果格式

```json
{
  "success": true,
  "message": "缓存失效已触发",
  "data": {
    "results": [
      {
        "ruleName": "direct-key-invalidation",
        "cacheType": "user",
        "invalidatedCount": 5,
        "success": true,
        "duration": 12
      }
    ],
    "timestamp": "2024-01-20T10:30:00.000Z",
    "totalOperations": 10,
    "successCount": 9,
    "failedCount": 1
  }
}
```

## 🔍 监控和调试

### 失效统计信息

```typescript
const stats = userCacheInvalidationService.getInvalidationStats();
console.log({
  totalRules: stats.totalRules,
  enabledRules: stats.enabledRules,
  pendingInvalidations: stats.pendingInvalidations
});
```

### 缓存实例状态

```typescript
import { userCache, statsCache } from '../lib/cacheInstances.js';

// 获取缓存统计
const userStats = userCache.getStats();
const statsStats = statsCache.getStats();

console.log({
  user: { size: userStats.size, hitRate: userStats.hitRate },
  stats: { size: statsStats.size, hitRate: statsStats.hitRate }
});
```

## 🚀 集成示例

### 在用户CRUD操作中集成

```typescript
// api/routes/admin/users/crud.ts
import { invalidateOnUserCreate, invalidateOnUserUpdate, invalidateOnUserDelete } from '../../../utils/userCacheInvalidation.js';

// 创建用户后
router.post('/', asyncHandler(async (req: Request, res: Response) => {
  // ... 用户创建逻辑 ...
  
  // 智能缓存失效
  await invalidateOnUserCreate();
  
  res.status(201).json(result);
}));

// 更新用户后
router.put('/:id', asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;
  // ... 用户更新逻辑 ...
  
  // 智能缓存失效
  await invalidateOnUserUpdate(id);
  
  res.json(result);
}));

// 删除用户后
router.delete('/:id', asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;
  // ... 用户删除逻辑 ...
  
  // 智能缓存失效
  await invalidateOnUserDelete(id);
  
  res.json({ message: '删除成功' });
}));
```

## ⚙️ 配置选项

### 失效选项接口

```typescript
interface UserCacheInvalidationOptions {
  userId?: string;              // 单个用户ID
  userIds?: string[];          // 批量用户ID
  type: UserCacheInvalidationType; // 失效类型
  invalidateStats?: boolean;    // 是否失效统计数据（默认: true）
  invalidateList?: boolean;     // 是否失效列表数据（默认: true）
  additionalPatterns?: string[]; // 额外的失效模式
  delay?: number;              // 延迟失效时间（毫秒）
}
```

### 缓存键模式

| 模式 | 说明 | 示例 |
|------|------|------|
| `user:{id}:*` | 特定用户的所有缓存 | `user:123:profile`, `user:123:posts` |
| `user:admin:list:*` | 管理后台用户列表 | `user:admin:list:{"page":1,"limit":20}` |
| `stats:admin:users` | 用户统计数据 | `stats:admin:users` |
| `api:*{userId}*` | 包含用户ID的API缓存 | `api:users:123:profile` |
| `session:*{userId}*` | 用户会话相关缓存 | `session:user:123:permissions` |

## 📈 性能指标

### 预期性能提升

| 操作类型 | 失效时间 | 影响范围 | 性能提升 |
|----------|----------|----------|----------|
| 用户创建 | < 50ms | 列表+统计 | 95% |
| 用户更新 | < 30ms | 详情+API | 90% |
| 用户删除 | < 100ms | 全部相关 | 85% |
| 状态变更 | < 40ms | 详情+会话 | 92% |
| 批量操作 | < 200ms | 多用户 | 80% |

### 缓存命中率目标

- **用户列表**: > 85%
- **用户统计**: > 90%
- **用户详情**: > 80%
- **API响应**: > 75%

## 🔧 故障排除

### 常见问题

1. **失效不生效**
   - 检查缓存键模式是否正确
   - 验证用户ID是否有效
   - 查看失效结果的错误信息

2. **性能问题**
   - 检查是否有过多的失效规则
   - 验证批量操作的用户数量
   - 考虑使用延迟失效

3. **数据不一致**
   - 确保所有用户操作都调用了失效
   - 检查失效的范围是否充分
   - 验证依赖关系是否正确

### 调试方法

```typescript
// 启用详细日志
process.env.CACHE_DEBUG = 'true';

// 手动测试失效
const results = await invalidateOnUserUpdate('test-user-id');
console.log('失效结果:', results);

// 检查缓存状态
const userStats = userCache.getStats();
console.log('用户缓存状态:', userStats);
```

## 🎯 最佳实践

### Do ✅

1. **及时失效**: 在数据修改后立即调用失效
2. **选择合适的类型**: 根据操作选择正确的失效类型
3. **批量操作**: 多个用户操作时使用批量失效
4. **监控性能**: 定期检查失效性能和命中率
5. **测试验证**: 使用测试API验证失效效果

### Don't ❌

1. **不要忘记失效**: 修改用户数据后忘记调用失效
2. **不要过度失效**: 避免不必要的缓存清理
3. **不要忽略错误**: 忽略失效过程中的错误
4. **不要阻塞用户**: 避免失效操作影响用户体验
5. **不要硬编码**: 避免硬编码缓存键或模式

---

## 📝 版本历史

- **v1.0.0** - 初始版本，支持基本的用户缓存失效
- **v1.1.0** - 添加批量失效和延迟失效
- **v1.2.0** - 增加测试API和监控功能
- **v1.3.0** - 优化性能和错误处理

---

*本文档由缓存优化团队维护，最后更新时间：2024-01-20*
