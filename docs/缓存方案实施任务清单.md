# 缓存方案实施任务清单

## 项目概述
- **项目名称**: biubiustar-ultra
- **技术栈**: React + TypeScript + Express + Supabase + Redis
- **目标**: 实现三层缓存架构，提升应用性能

## 阶段一：基础设施准备 (1-2天)

### 1.1 安装依赖包
```bash
# 服务端依赖
npm install ioredis @types/ioredis

# 客户端依赖 (已安装)
# zustand - 状态管理
# clsx - 工具库
```

### 1.2 环境配置
- [ ] 在 `deployment/configs/env.example` 添加 Redis 配置
- [ ] 在 `deployment/configs/ecosystem.config.js` 添加 Redis 环境变量
- [ ] 确保 Docker Compose 中的 Redis 服务配置正确

### 1.3 Redis 服务启动
```bash
cd deployment
docker-compose up redis -d
```

## 阶段二：服务端 Redis 缓存 (2-3天)

### 2.1 创建 Redis 连接模块
- [ ] 创建 `api/lib/redis.ts`
- [ ] 实现 Redis 连接池和错误处理
- [ ] 添加连接状态监控

### 2.2 实现缓存中间件
- [ ] 创建 `api/middleware/cache.ts`
- [ ] 实现 GET 请求缓存逻辑
- [ ] 添加缓存响应装饰器

### 2.3 缓存工具类
- [ ] 创建 `api/utils/cacheInvalidation.ts`
- [ ] 实现智能缓存失效策略
- [ ] 创建 `api/utils/cacheWarmup.ts` 预热机制

### 2.4 集成到现有路由
- [ ] 在 `api/routes/activities.ts` 添加缓存
- [ ] 在 `api/routes/posts/index.ts` 添加缓存
- [ ] 在 `api/routes/users/index.ts` 添加缓存
- [ ] 在 `api/routes/categories/index.ts` 添加缓存

## 阶段三：客户端缓存优化 (2-3天)

### 3.1 创建缓存存储
- [ ] 创建 `src/stores/cacheStore.ts`
- [ ] 实现内存缓存逻辑
- [ ] 添加过期时间管理

### 3.2 持久化缓存工具
- [ ] 创建 `src/utils/cache.ts`
- [ ] 实现 localStorage 缓存管理
- [ ] 添加版本控制和过期清理

### 3.3 API 缓存装饰器
- [ ] 创建 `src/utils/apiCache.ts`
- [ ] 实现 withCache 高阶函数
- [ ] 支持不同缓存策略配置

### 3.4 缓存配置管理
- [ ] 创建 `src/config/cache.ts`
- [ ] 定义不同类型数据的缓存策略
- [ ] 实现缓存时间配置

## 阶段四：缓存策略实施 (2-3天)

### 4.1 用户数据缓存
- [ ] 用户资料缓存 (TTL: 10分钟)
- [ ] 用户设置缓存 (TTL: 30分钟)
- [ ] 用户帖子缓存 (TTL: 5分钟)

### 4.2 内容数据缓存
- [ ] 活动列表缓存 (TTL: 5分钟)
- [ ] 帖子列表缓存 (TTL: 3分钟)
- [ ] 分类数据缓存 (TTL: 1小时)

### 4.3 系统设置缓存
- [ ] 基础设置缓存 (TTL: 1小时)
- [ ] 语言配置缓存 (TTL: 24小时)
- [ ] 主题设置缓存 (TTL: 24小时)

## 阶段五：性能优化和监控 (1-2天)

### 5.1 缓存性能监控
- [ ] 创建 `api/utils/cacheMetrics.ts`
- [ ] 实现缓存命中率统计
- [ ] 添加响应时间监控

### 5.2 客户端缓存优化
- [ ] 创建 `src/hooks/useCacheOptimization.ts`
- [ ] 实现定期清理过期缓存
- [ ] 添加页面卸载时的缓存清理

### 5.3 缓存预热机制
- [ ] 实现应用启动时的数据预热
- [ ] 添加定时刷新机制
- [ ] 实现智能预加载策略

## 阶段六：测试和验证 (2-3天)

### 6.1 功能测试
- [ ] 测试 Redis 连接和基本操作
- [ ] 验证缓存中间件功能
- [ ] 测试客户端缓存逻辑

### 6.2 性能测试
- [ ] 对比缓存前后的响应时间
- [ ] 测试缓存命中率
- [ ] 验证内存使用情况

### 6.3 压力测试
- [ ] 测试高并发下的缓存性能
- [ ] 验证缓存失效策略
- [ ] 测试缓存预热效果

## 阶段七：部署和监控 (1-2天)

### 7.1 生产环境部署
- [ ] 更新生产环境配置
- [ ] 部署 Redis 服务
- [ ] 配置生产环境缓存策略

### 7.2 监控和告警
- [ ] 设置缓存性能监控
- [ ] 配置缓存异常告警
- [ ] 实现缓存健康检查

## 详细实施步骤

### 步骤 1: Redis 服务配置
```bash
# 1. 启动 Redis 服务
cd deployment
docker-compose up redis -d

# 2. 验证 Redis 连接
docker exec -it biubiustar-redis redis-cli ping
```

### 步骤 2: 创建 Redis 连接模块
```typescript
// api/lib/redis.ts
import Redis from 'ioredis';

class RedisCache {
  private redis: Redis;
  
  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
      db: 0,
      retryDelayOnFailover: 100,
      maxRetriesPerRequest: 3,
      lazyConnect: true
    });
    
    this.redis.on('error', (err) => {
      console.error('Redis 连接错误:', err);
    });
    
    this.redis.on('connect', () => {
      console.log('Redis 连接成功');
    });
  }
  
  async set(key: string, value: any, ttl: number = 3600): Promise<void> {
    try {
      const serialized = JSON.stringify(value);
      await this.redis.setex(key, ttl, serialized);
    } catch (error) {
      console.error('Redis 设置缓存失败:', error);
    }
  }
  
  async get(key: string): Promise<any | null> {
    try {
      const value = await this.redis.get(key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      console.error('Redis 获取缓存失败:', error);
      return null;
    }
  }
  
  async del(key: string): Promise<void> {
    try {
      await this.redis.del(key);
    } catch (error) {
      console.error('Redis 删除缓存失败:', error);
    }
  }
  
  async clearPattern(pattern: string): Promise<void> {
    try {
      const keys = await this.redis.keys(pattern);
      if (keys.length > 0) {
        await this.redis.del(...keys);
      }
    } catch (error) {
      console.error('Redis 批量删除缓存失败:', error);
    }
  }
}

export const redisCache = new RedisCache();
```

### 步骤 3: 实现缓存中间件
```typescript
// api/middleware/cache.ts
import { Request, Response, NextFunction } from 'express';
import { redisCache } from '../lib/redis.js';

interface CacheOptions {
  ttl?: number;
  key?: string | ((req: Request) => string);
  condition?: (req: Request) => boolean;
}

export function cacheMiddleware(options: CacheOptions = {}) {
  const { ttl = 300, key, condition } = options;
  
  return async (req: Request, res: Response, next: NextFunction) => {
    if (req.method !== 'GET') {
      return next();
    }
    
    if (condition && !condition(req)) {
      return next();
    }
    
    const cacheKey = typeof key === 'function' 
      ? key(req) 
      : key || `api:${req.originalUrl}`;
    
    try {
      const cached = await redisCache.get(cacheKey);
      if (cached) {
        return res.json(cached);
      }
      next();
    } catch (error) {
      console.error('缓存中间件错误:', error);
      next();
    }
  };
}

export function cacheResponse(ttl: number = 300) {
  return (req: Request, res: Response, next: NextFunction) => {
    const originalJson = res.json;
    
    res.json = function(data: any) {
      const cacheKey = `api:${req.originalUrl}`;
      redisCache.set(cacheKey, data, ttl);
      return originalJson.call(this, data);
    };
    
    next();
  };
}
```

### 步骤 4: 在路由中应用缓存
```typescript
// api/routes/activities.ts
import { cacheMiddleware, cacheResponse } from '../middleware/cache.js';

// 获取活动列表 - 缓存5分钟
router.get('/', 
  cacheMiddleware({ ttl: 300, key: 'activities:list' }),
  cacheResponse(300),
  async (req, res) => {
    // 原有逻辑
  }
);

// 获取单个活动 - 缓存10分钟
router.get('/:id', 
  cacheMiddleware({ 
    ttl: 600, 
    key: (req) => `activity:${req.params.id}` 
  }),
  cacheResponse(600),
  async (req, res) => {
    // 原有逻辑
  }
);
```

### 步骤 5: 创建客户端缓存存储
```typescript
// src/stores/cacheStore.ts
import { create } from 'zustand';

interface CacheItem {
  data: any;
  timestamp: number;
  ttl: number;
}

interface CacheStore {
  cache: Map<string, CacheItem>;
  set: (key: string, data: any, ttl?: number) => void;
  get: (key: string) => any | null;
  clear: () => void;
  clearExpired: () => void;
}

export const useCacheStore = create<CacheStore>((set, get) => ({
  cache: new Map(),
  
  set: (key, data, ttl = 5 * 60 * 1000) => {
    const item: CacheItem = {
      data,
      timestamp: Date.now(),
      ttl
    };
    set(state => ({
      cache: new Map(state.cache).set(key, item)
    }));
  },
  
  get: (key) => {
    const state = get();
    const item = state.cache.get(key);
    
    if (!item) return null;
    
    if (Date.now() - item.timestamp > item.ttl) {
      state.cache.delete(key);
      return null;
    }
    
    return item.data;
  },
  
  clear: () => set({ cache: new Map() }),
  
  clearExpired: () => {
    const state = get();
    const now = Date.now();
    const newCache = new Map();
    
    state.cache.forEach((item, key) => {
      if (now - item.timestamp <= item.ttl) {
        newCache.set(key, item);
      }
    });
    
    set({ cache: newCache });
  }
}));
```

### 步骤 6: 实现持久化缓存工具
```typescript
// src/utils/cache.ts
export class PersistentCache {
  private static readonly VERSION = '1.0.0';
  private static readonly PREFIX = 'biubiustar_cache_';
  
  static set(key: string, data: any, ttl: number = 24 * 60 * 60 * 1000) {
    const item = {
      data,
      timestamp: Date.now(),
      ttl,
      version: this.VERSION
    };
    
    try {
      localStorage.setItem(
        this.PREFIX + key, 
        JSON.stringify(item)
      );
    } catch (error) {
      console.warn('缓存存储失败:', error);
      this.clearExpired();
    }
  }
  
  static get(key: string): any | null {
    try {
      const item = localStorage.getItem(this.PREFIX + key);
      if (!item) return null;
      
      const parsed = JSON.parse(item);
      
      if (parsed.version !== this.VERSION) {
        this.remove(key);
        return null;
      }
      
      if (Date.now() - parsed.timestamp > parsed.ttl) {
        this.remove(key);
        return null;
      }
      
      return parsed.data;
    } catch (error) {
      this.remove(key);
      return null;
    }
  }
  
  static remove(key: string) {
    localStorage.removeItem(this.PREFIX + key);
  }
  
  static clearExpired() {
    const keys = Object.keys(localStorage);
    const now = Date.now();
    
    keys.forEach(key => {
      if (key.startsWith(this.PREFIX)) {
        try {
          const item = JSON.parse(localStorage.getItem(key)!);
          if (now - item.timestamp > item.ttl) {
            localStorage.removeItem(key);
          }
        } catch {
          localStorage.removeItem(key);
        }
      }
    });
  }
}
```

### 步骤 7: 创建缓存配置
```typescript
// src/config/cache.ts
export const CACHE_CONFIG = {
  // 用户相关数据
  user: {
    profile: { ttl: 10 * 60 * 1000, persistent: true, memory: true },
    posts: { ttl: 5 * 60 * 1000, persistent: false, memory: true },
    settings: { ttl: 30 * 60 * 1000, persistent: true, memory: true }
  },
  
  // 内容相关数据
  content: {
    activities: { ttl: 2 * 60 * 1000, persistent: false, memory: true },
    posts: { ttl: 3 * 60 * 1000, persistent: false, memory: true },
    categories: { ttl: 60 * 60 * 1000, persistent: true, memory: true }
  },
  
  // 系统设置
  system: {
    settings: { ttl: 60 * 60 * 1000, persistent: true, memory: true },
    languages: { ttl: 24 * 60 * 60 * 1000, persistent: true, memory: true }
  }
};
```

## 测试验证清单

### 功能测试
- [ ] Redis 连接测试
- [ ] 缓存设置和获取测试
- [ ] 缓存过期测试
- [ ] 缓存失效测试

### 性能测试
- [ ] 缓存命中率 > 80%
- [ ] 响应时间减少 > 50%
- [ ] 数据库查询减少 > 70%

### 压力测试
- [ ] 1000 并发用户测试
- [ ] 内存使用监控
- [ ] Redis 性能监控

## 部署检查清单

### 环境配置
- [ ] Redis 服务正常运行
- [ ] 环境变量配置正确
- [ ] 网络连接正常

### 监控配置
- [ ] 缓存性能监控开启
- [ ] 异常告警配置
- [ ] 日志记录完整

## 预期效果

### 性能提升
- **响应时间**: 减少 50-80%
- **数据库负载**: 减少 60-80%
- **用户体验**: 显著提升

### 系统稳定性
- **缓存命中率**: 80-95%
- **系统可用性**: 99.9%+
- **错误率**: 减少 70%+

## 风险控制

### 技术风险
- **Redis 连接失败**: 实现降级策略
- **缓存穿透**: 实现布隆过滤器
- **缓存雪崩**: 设置随机过期时间

### 运维风险
- **内存溢出**: 监控内存使用
- **网络延迟**: 配置超时重试
- **数据一致性**: 实现缓存失效策略

## 后续优化

### 短期优化 (1-2周)
- 缓存预热机制
- 智能预加载
- 缓存压缩

### 中期优化 (1-2月)
- 分布式缓存
- 缓存集群
- 智能路由

### 长期优化 (3-6月)
- 机器学习缓存策略
- 自适应缓存大小
- 跨区域缓存同步

---

**总预计时间**: 10-15 个工作日  
**优先级**: 高  
**影响范围**: 全应用性能提升  
**负责人**: 开发团队  
**审核人**: 技术负责人**
