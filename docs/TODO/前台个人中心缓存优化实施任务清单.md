# å‰å°ä¸ªäººä¸­å¿ƒç¼“å­˜ä¼˜åŒ–å®æ–½ä»»åŠ¡æ¸…å•

## ğŸ“Š é¡¹ç›®æ¦‚è§ˆ

**é¡¹ç›®åç§°**: å‰å°ä¸ªäººä¸­å¿ƒç¼“å­˜ç³»ç»Ÿä¼˜åŒ–  
**å½“å‰ç¼“å­˜è¦†ç›–ç‡**: < 20%  
**ç›®æ ‡ç¼“å­˜è¦†ç›–ç‡**: 85%+  
**é¢„æœŸæ€§èƒ½æå‡**: ä¸ªäººä¸­å¿ƒé¡µé¢åŠ è½½é€Ÿåº¦æå‡70%ï¼Œä»800msé™è‡³200ms  
**å®æ–½å‘¨æœŸ**: 3å‘¨  

---

## ğŸ” å½“å‰çŠ¶å†µåˆ†æ

### âœ… å·²å®ç°ç¼“å­˜çš„æ¨¡å—
1. **ç”¨æˆ·èµ„æ–™æŸ¥è¯¢** - `GET /api/users/:id/profile`
   - ç¼“å­˜å®ä¾‹: `userCache`
   - TTL: é»˜è®¤ä¸­ç­‰æ—¶é•¿
   - çŠ¶æ€: âœ… å·²å®ç°

2. **å¤´åƒä¸Šä¼ ** - `POST /api/users/avatar`
   - ç¼“å­˜å¤±æ•ˆ: âœ… å·²å®ç°è‡ªåŠ¨å¤±æ•ˆæœºåˆ¶

### âŒ æœªå®ç°ç¼“å­˜çš„æ¨¡å—
1. **ç”¨æˆ·å¸–å­åˆ—è¡¨** - `GET /api/users/:id/posts`
2. **ç”¨æˆ·æ´»åŠ¨åˆ—è¡¨** - `GET /api/users/:id/activities` 
3. **ç”¨æˆ·åˆ›å»ºçš„æ´»åŠ¨** - `GET /api/users/:id/created-activities`
4. **ç”¨æˆ·ç»Ÿè®¡æ•°æ®** - å‰ç«¯è®¡ç®—ï¼Œéœ€è¦APIç¼“å­˜æ”¯æŒ
5. **é€šçŸ¥ç³»ç»Ÿ** - ç›®å‰ä¸ºæ¨¡æ‹Ÿæ•°æ®ï¼Œéœ€è¦å®Œæ•´å®ç°
6. **ç¤¾äº¤å…³ç³»** - å…³æ³¨/ç²‰ä¸åˆ—è¡¨ç­‰

---

## ğŸ¯ é˜¶æ®µä¸€ï¼šæ ¸å¿ƒæ•°æ®ç¼“å­˜ (ç¬¬1å‘¨) - é«˜ä¼˜å…ˆçº§

### 1. ç”¨æˆ·å¸–å­åˆ—è¡¨ç¼“å­˜ä¼˜åŒ–

#### 1.1 ç”¨æˆ·å¸–å­æŸ¥è¯¢ç¼“å­˜
**ä¼˜å…ˆçº§**: ğŸ”¥ æœ€é«˜  
**é¢„ä¼°å·¥æ—¶**: 3å°æ—¶  
**æ–‡ä»¶æ¶‰åŠ**: `api/routes/users/posts.ts`, `src/hooks/useUserProfile.ts`

**å®æ–½æ­¥éª¤**:

##### åç«¯APIç¼“å­˜å®ç°
```typescript
// api/routes/users/posts.ts
import { userCache } from '../../lib/cacheInstances.js'
import { CacheKeyGenerator, CACHE_TTL } from '../../config/cache.js'
import { createUserSpecificCacheMiddleware } from '../../middleware/cache.js'

// æ·»åŠ ç¼“å­˜ä¸­é—´ä»¶åˆ°ç°æœ‰è·¯ç”±
router.get('/:id/posts', 
  createUserSpecificCacheMiddleware({
    cacheService: userCache,
    keyGenerator: (req) => {
      const { id } = req.params
      const { limit = 10, offset = 0, category, status } = req.query
      return CacheKeyGenerator.userPosts(id, {
        limit: Number(limit),
        offset: Number(offset),
        category: category as string,
        status: status as string
      })
    },
    ttl: CACHE_TTL.MEDIUM // 10åˆ†é’Ÿ
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    // ç°æœ‰é€»è¾‘ä¿æŒä¸å˜ï¼Œä¸­é—´ä»¶ä¼šè‡ªåŠ¨å¤„ç†ç¼“å­˜
    // ... ç°æœ‰ä»£ç  ...
  })
)
```

##### ç¼“å­˜é”®ç”Ÿæˆå™¨æ‰©å±•
```typescript
// api/config/cache.ts
export class CacheKeyGenerator {
  // ... ç°æœ‰æ–¹æ³• ...
  
  // ç”¨æˆ·ä¸ªäººä¸­å¿ƒç›¸å…³ç¼“å­˜é”®
  static userPosts(userId: string, options: {
    limit: number;
    offset: number;
    category?: string;
    status?: string;
  }): string {
    const params = JSON.stringify(options)
    return `${CACHE_PREFIXES.USER}${userId}:posts:${params}`
  }
  
  static userActivities(userId: string, options: {
    limit: number;
    offset: number;
    category?: string;
    status?: string;
  }): string {
    const params = JSON.stringify(options)
    return `${CACHE_PREFIXES.USER}${userId}:activities:${params}`
  }
  
  static userCreatedActivities(userId: string, options: {
    limit: number;
    offset: number;
    category?: string;
    status?: string;
  }): string {
    const params = JSON.stringify(options)
    return `${CACHE_PREFIXES.USER}${userId}:created_activities:${params}`
  }
  
  static userStats(userId: string): string {
    return `${CACHE_PREFIXES.STATS}user:${userId}`
  }
  
  static userNotifications(userId: string, options: {
    limit?: number;
    offset?: number;
    unreadOnly?: boolean;
  } = {}): string {
    const params = JSON.stringify(options)
    return `${CACHE_PREFIXES.USER}${userId}:notifications:${params}`
  }
}
```

##### å‰ç«¯ä¼˜åŒ– - useUserProfile Hook
```typescript
// src/hooks/useUserProfile.ts 
// åœ¨ç°æœ‰åŸºç¡€ä¸Šæ·»åŠ ç¼“å­˜æ„ŸçŸ¥é€»è¾‘

export const useUserProfile = () => {
  // ... ç°æœ‰çŠ¶æ€ ...
  
  // æ–°å¢ç¼“å­˜çŠ¶æ€
  const [cacheStatus, setCacheStatus] = useState<{
    posts: boolean;
    activities: boolean;
    profile: boolean;
    stats: boolean;
  }>({
    posts: false,
    activities: false,
    profile: false,
    stats: false
  })

  // ä¼˜åŒ–åŠ è½½ç”¨æˆ·æ•°æ®å‡½æ•°
  const loadUserData = useCallback(async () => {
    if (!user) return
    
    try {
      setIsLoading(true)
      
      // å¹¶è¡ŒåŠ è½½æ‰€æœ‰æ•°æ®ï¼Œåˆ©ç”¨ç¼“å­˜
      const [profile, postsResponse, activities] = await Promise.all([
        socialService.getUserProfile(user.id),
        socialService.getUserPosts(user.id),
        ActivityService.getUserActivities(user.id)
      ])
      
      // æ£€æŸ¥ç¼“å­˜å‘½ä¸­çŠ¶æ€ï¼ˆå¦‚æœAPIè¿”å›ç¼“å­˜æ ‡è¯†ï¼‰
      setCacheStatus({
        profile: profile?.cached || false,
        posts: postsResponse?.cached || false,
        activities: activities?.cached || false,
        stats: false // ç»Ÿè®¡æ•°æ®ç”±å‰ç«¯è®¡ç®—
      })
      
      setUserProfile(profile)
      
      const posts = Array.isArray(postsResponse) ? postsResponse : postsResponse.posts || []
      setUserPosts(posts)
      setUserActivities(activities)
      
      // ç¼“å­˜ç»Ÿè®¡æ•°æ®è®¡ç®—ç»“æœ
      const stats = {
        postsCount: posts.length,
        followersCount: profile?.followers_count || 0,
        followingCount: profile?.following_count || 0,
        likes: posts.reduce((sum: number, post: any) => sum + (post.likes_count || 0), 0)
      }
      setUserStats(stats)
      
    } catch (error) {
      console.error('åŠ è½½ç”¨æˆ·æ•°æ®å¤±è´¥:', error)
      toast.error('åŠ è½½ç”¨æˆ·æ•°æ®å¤±è´¥')
    } finally {
      setIsLoading(false)
    }
  }, [user])
  
  // æ·»åŠ å¼ºåˆ¶åˆ·æ–°æ–¹æ³•ï¼ˆè·³è¿‡ç¼“å­˜ï¼‰
  const forceRefreshData = useCallback(async () => {
    if (!user) return
    
    try {
      setIsLoading(true)
      
      // æ·»åŠ cache-control headerå¼ºåˆ¶è·³è¿‡ç¼“å­˜
      const headers = { 'Cache-Control': 'no-cache' }
      
      const [profile, postsResponse, activities] = await Promise.all([
        fetch(`/api/users/${user.id}/profile`, { headers }).then(r => r.json()),
        fetch(`/api/users/${user.id}/posts?limit=100`, { headers }).then(r => r.json()),
        fetch(`/api/users/${user.id}/activities?limit=100`, { headers }).then(r => r.json())
      ])
      
      // æ›´æ–°æ‰€æœ‰çŠ¶æ€...
      // ... å¤„ç†é€»è¾‘ ...
      
    } catch (error) {
      console.error('å¼ºåˆ¶åˆ·æ–°å¤±è´¥:', error)
      toast.error('åˆ·æ–°å¤±è´¥')
    } finally {
      setIsLoading(false)
    }
  }, [user])

  return {
    // ... ç°æœ‰è¿”å›å€¼ ...
    cacheStatus,
    forceRefreshData
  }
}
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] ç”¨æˆ·å¸–å­æŸ¥è¯¢æ—¶é—´ä» 300ms é™è‡³ 50ms
- [ ] ç¼“å­˜å‘½ä¸­ç‡è¾¾åˆ° 80%ä»¥ä¸Š
- [ ] å‰ç«¯æ˜¾ç¤ºç¼“å­˜çŠ¶æ€æŒ‡ç¤ºå™¨
- [ ] æ”¯æŒåˆ†é¡µå’Œç­›é€‰çš„ç¼“å­˜

---

#### 1.2 ç”¨æˆ·æ´»åŠ¨åˆ—è¡¨ç¼“å­˜
**ä¼˜å…ˆçº§**: ğŸ”¥ é«˜  
**é¢„ä¼°å·¥æ—¶**: 3å°æ—¶  

**å®æ–½æ­¥éª¤**:

##### å‚ä¸æ´»åŠ¨åˆ—è¡¨ç¼“å­˜
```typescript
// api/routes/users/posts.ts (åœ¨ç°æœ‰GET /:id/activitiesè·¯ç”±ä¸Šæ·»åŠ ç¼“å­˜)
router.get('/:id/activities',
  createUserSpecificCacheMiddleware({
    cacheService: userCache,
    keyGenerator: (req) => {
      const { id } = req.params
      const { limit = 10, offset = 0, category, status = 'published' } = req.query
      return CacheKeyGenerator.userActivities(id, {
        limit: Number(limit),
        offset: Number(offset),
        category: category as string,
        status: status as string
      })
    },
    ttl: CACHE_TTL.MEDIUM
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    // ç°æœ‰é€»è¾‘ä¿æŒä¸å˜
    // ... ç°æœ‰ä»£ç  ...
  })
)

// åˆ›å»ºæ´»åŠ¨åˆ—è¡¨ç¼“å­˜
router.get('/:id/created-activities',
  createUserSpecificCacheMiddleware({
    cacheService: userCache,
    keyGenerator: (req) => {
      const { id } = req.params
      const { limit = 10, offset = 0, category, status = 'published' } = req.query
      return CacheKeyGenerator.userCreatedActivities(id, {
        limit: Number(limit),
        offset: Number(offset),
        category: category as string,
        status: status as string
      })
    },
    ttl: CACHE_TTL.MEDIUM
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    // ç°æœ‰é€»è¾‘ä¿æŒä¸å˜
    // ... ç°æœ‰ä»£ç  ...
  })
)
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] æ´»åŠ¨åˆ—è¡¨æŸ¥è¯¢æ—¶é—´ä» 400ms é™è‡³ 60ms
- [ ] æ”¯æŒå‚ä¸æ´»åŠ¨å’Œåˆ›å»ºæ´»åŠ¨çš„åˆ†åˆ«ç¼“å­˜
- [ ] ç¼“å­˜å‘½ä¸­ç‡è¾¾åˆ° 75%ä»¥ä¸Š

---

#### 1.3 ç”¨æˆ·ç»Ÿè®¡æ•°æ®ä¼˜åŒ–
**ä¼˜å…ˆçº§**: ğŸ”¥ ä¸­  
**é¢„ä¼°å·¥æ—¶**: 2å°æ—¶  

**å®æ–½æ­¥éª¤**:

##### æ–°å»ºç”¨æˆ·ç»Ÿè®¡API
```typescript
// api/routes/users/stats.ts (æ–°å¢æ–‡ä»¶)
import { Router, Request, Response } from 'express'
import { supabase } from '../../lib/supabase'
import { statsCache } from '../../lib/cacheInstances.js'
import { CacheKeyGenerator, CACHE_TTL } from '../../config/cache.js'
import { createUserSpecificCacheMiddleware } from '../../middleware/cache.js'
import asyncHandler from '../../middleware/asyncHandler.js'

const router = Router()

// GET /api/users/:id/stats - è·å–ç”¨æˆ·ç»Ÿè®¡æ•°æ®
router.get('/:id/stats',
  createUserSpecificCacheMiddleware({
    cacheService: statsCache,
    keyGenerator: (req) => CacheKeyGenerator.userStats(req.params.id),
    ttl: CACHE_TTL.SHORT // 5åˆ†é’Ÿï¼Œä¿æŒæ•°æ®è¾ƒæ–°
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const { id } = req.params
      
      // å¹¶è¡Œè·å–å„ç§ç»Ÿè®¡æ•°æ®
      const [
        { count: postsCount },
        { count: activitiesCount },
        { count: createdActivitiesCount },
        { data: socialData }
      ] = await Promise.all([
        // å¸–å­æ•°é‡
        supabase
          .from('posts')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', id)
          .eq('status', 'published'),
        
        // å‚ä¸æ´»åŠ¨æ•°é‡
        supabase
          .from('activity_participants')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', id),
        
        // åˆ›å»ºæ´»åŠ¨æ•°é‡
        supabase
          .from('activities')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', id)
          .eq('status', 'published'),
        
        // ç¤¾äº¤æ•°æ®ï¼ˆå…³æ³¨ã€ç²‰ä¸ã€ç‚¹èµï¼‰
        supabase
          .from('user_profiles')
          .select('followers_count, following_count')
          .eq('id', id)
          .single()
      ])
      
      // è®¡ç®—æ€»è·èµæ•°
      const { data: posts } = await supabase
        .from('posts')
        .select('likes_count')
        .eq('user_id', id)
      
      const totalLikes = posts?.reduce((sum, post) => sum + (post.likes_count || 0), 0) || 0
      
      const statsData = {
        postsCount: postsCount || 0,
        activitiesCount: activitiesCount || 0,
        createdActivitiesCount: createdActivitiesCount || 0,
        followersCount: socialData?.followers_count || 0,
        followingCount: socialData?.following_count || 0,
        totalLikes,
        lastUpdated: new Date().toISOString()
      }
      
      res.json({
        success: true,
        data: statsData,
        cached: false
      })
      
    } catch (error) {
      console.error('è·å–ç”¨æˆ·ç»Ÿè®¡å¤±è´¥:', error)
      res.status(500).json({
        success: false,
        error: 'è·å–ç”¨æˆ·ç»Ÿè®¡å¤±è´¥'
      })
    }
  })
)

export default router
```

##### é›†æˆåˆ°ä¸»è·¯ç”±
```typescript
// api/routes/users/index.ts
import statsRoutes from './stats.js'

// æ·»åŠ ç»Ÿè®¡è·¯ç”±
router.use('/', statsRoutes)
```

##### å‰ç«¯ä½¿ç”¨ä¼˜åŒ–ç»Ÿè®¡API
```typescript
// src/hooks/useUserProfile.ts
const loadUserData = useCallback(async () => {
  if (!user) return
  
  try {
    setIsLoading(true)
    
    // ä½¿ç”¨ä¸“é—¨çš„ç»Ÿè®¡APIï¼Œè€Œä¸æ˜¯å‰ç«¯è®¡ç®—
    const [profile, postsResponse, activities, stats] = await Promise.all([
      socialService.getUserProfile(user.id),
      socialService.getUserPosts(user.id),
      ActivityService.getUserActivities(user.id),
      fetch(`/api/users/${user.id}/stats`).then(r => r.json()) // æ–°å¢ç»Ÿè®¡APIè°ƒç”¨
    ])
    
    // è®¾ç½®ç»Ÿè®¡æ•°æ®
    if (stats.success) {
      setUserStats(stats.data)
    }
    
    // ... å…¶ä»–å¤„ç†é€»è¾‘ ...
    
  } catch (error) {
    console.error('åŠ è½½ç”¨æˆ·æ•°æ®å¤±è´¥:', error)
    toast.error('åŠ è½½ç”¨æˆ·æ•°æ®å¤±è´¥')
  } finally {
    setIsLoading(false)
  }
}, [user])
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] ç»Ÿè®¡æ•°æ®æŸ¥è¯¢æ—¶é—´ä» 600ms é™è‡³ 80ms  
- [ ] ç»Ÿè®¡æ•°æ®å®æ—¶æ€§ä¿æŒåœ¨5åˆ†é’Ÿå†…
- [ ] æ”¯æŒå¤šç»´åº¦ç»Ÿè®¡ï¼ˆå¸–å­ã€æ´»åŠ¨ã€ç¤¾äº¤ç­‰ï¼‰

---

## ğŸš€ é˜¶æ®µäºŒï¼šé€šçŸ¥ä¸ç¤¾äº¤åŠŸèƒ½ç¼“å­˜ (ç¬¬2å‘¨) - ä¸­ä¼˜å…ˆçº§

### 2. é€šçŸ¥ç³»ç»Ÿå®Œæ•´å®ç°ä¸ç¼“å­˜

#### 2.1 é€šçŸ¥APIå®ç°ä¸ç¼“å­˜
**ä¼˜å…ˆçº§**: ğŸ”¥ ä¸­  
**é¢„ä¼°å·¥æ—¶**: 5å°æ—¶  

**å®æ–½æ­¥éª¤**:

##### é€šçŸ¥æ•°æ®è¡¨è®¾è®¡ï¼ˆå¦‚æœè¿˜æœªåˆ›å»ºï¼‰
```sql
-- supabase/migrations/create_notifications_table.sql
CREATE TABLE IF NOT EXISTS notifications (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  type VARCHAR(50) NOT NULL, -- 'like', 'comment', 'follow', 'activity', 'system'
  title VARCHAR(255) NOT NULL,
  message TEXT NOT NULL,
  data JSONB, -- ç›¸å…³æ•°æ®ï¼Œå¦‚post_id, comment_idç­‰
  read BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_notifications_user_id ON notifications(user_id);
CREATE INDEX idx_notifications_read ON notifications(read);
CREATE INDEX idx_notifications_created_at ON notifications(created_at DESC);
```

##### é€šçŸ¥APIå®ç°
```typescript
// api/routes/users/notifications.ts (æ–°å¢æ–‡ä»¶)
import { Router, Request, Response } from 'express'
import { supabaseAdmin } from '../../lib/supabase.js'
import { userCache } from '../../lib/cacheInstances.js'
import { CacheKeyGenerator, CACHE_TTL } from '../../config/cache.js'
import { createUserSpecificCacheMiddleware } from '../../middleware/cache.js'
import asyncHandler from '../../middleware/asyncHandler.js'

const router = Router()

// GET /api/users/:id/notifications - è·å–ç”¨æˆ·é€šçŸ¥åˆ—è¡¨
router.get('/:id/notifications',
  createUserSpecificCacheMiddleware({
    cacheService: userCache,
    keyGenerator: (req) => {
      const { id } = req.params
      const { limit = 20, offset = 0, unreadOnly = false } = req.query
      return CacheKeyGenerator.userNotifications(id, {
        limit: Number(limit),
        offset: Number(offset),
        unreadOnly: unreadOnly === 'true'
      })
    },
    ttl: CACHE_TTL.SHORT // 3åˆ†é’Ÿï¼Œé€šçŸ¥éœ€è¦è¾ƒé«˜å®æ—¶æ€§
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const { id } = req.params
      const { limit = 20, offset = 0, unreadOnly = false } = req.query
      
      let query = supabaseAdmin
        .from('notifications')
        .select('*')
        .eq('user_id', id)
        .order('created_at', { ascending: false })
        .range(Number(offset), Number(offset) + Number(limit) - 1)
      
      if (unreadOnly === 'true') {
        query = query.eq('read', false)
      }
      
      const { data: notifications, error, count } = await query
      
      if (error) {
        throw error
      }
      
      // è·å–æœªè¯»æ•°é‡
      const { count: unreadCount } = await supabaseAdmin
        .from('notifications')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', id)
        .eq('read', false)
      
      res.json({
        success: true,
        data: {
          notifications: notifications || [],
          total: count || 0,
          unreadCount: unreadCount || 0
        },
        cached: false
      })
      
    } catch (error) {
      console.error('è·å–ç”¨æˆ·é€šçŸ¥å¤±è´¥:', error)
      res.status(500).json({
        success: false,
        error: 'è·å–ç”¨æˆ·é€šçŸ¥å¤±è´¥'
      })
    }
  })
)

// PUT /api/users/:id/notifications/:notificationId/read - æ ‡è®°é€šçŸ¥ä¸ºå·²è¯»
router.put('/:id/notifications/:notificationId/read',
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const { id, notificationId } = req.params
      
      const { error } = await supabaseAdmin
        .from('notifications')
        .update({ 
          read: true,
          updated_at: new Date().toISOString()
        })
        .eq('id', notificationId)
        .eq('user_id', id)
      
      if (error) {
        throw error
      }
      
      // æ¸…é™¤ç›¸å…³ç¼“å­˜
      const cacheKeys = userCache.keys().filter(key => 
        key.includes(`user:${id}:notifications`)
      )
      await userCache.mdel(cacheKeys)
      
      res.json({
        success: true,
        message: 'é€šçŸ¥å·²æ ‡è®°ä¸ºå·²è¯»'
      })
      
    } catch (error) {
      console.error('æ ‡è®°é€šçŸ¥å·²è¯»å¤±è´¥:', error)
      res.status(500).json({
        success: false,
        error: 'æ ‡è®°é€šçŸ¥å·²è¯»å¤±è´¥'
      })
    }
  })
)

// PUT /api/users/:id/notifications/mark-all-read - å…¨éƒ¨æ ‡è®°ä¸ºå·²è¯»
router.put('/:id/notifications/mark-all-read',
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const { id } = req.params
      
      const { error } = await supabaseAdmin
        .from('notifications')
        .update({ 
          read: true,
          updated_at: new Date().toISOString()
        })
        .eq('user_id', id)
        .eq('read', false)
      
      if (error) {
        throw error
      }
      
      // æ¸…é™¤ç›¸å…³ç¼“å­˜
      const cacheKeys = userCache.keys().filter(key => 
        key.includes(`user:${id}:notifications`)
      )
      await userCache.mdel(cacheKeys)
      
      res.json({
        success: true,
        message: 'æ‰€æœ‰é€šçŸ¥å·²æ ‡è®°ä¸ºå·²è¯»'
      })
      
    } catch (error) {
      console.error('å…¨éƒ¨æ ‡è®°å·²è¯»å¤±è´¥:', error)
      res.status(500).json({
        success: false,
        error: 'å…¨éƒ¨æ ‡è®°å·²è¯»å¤±è´¥'
      })
    }
  })
)

export default router
```

##### å‰ç«¯NotificationsListç»„ä»¶é‡æ„
```typescript
// src/pages/profile/NotificationsList.tsx
import React, { useState, useEffect } from 'react'
import { useAuth } from '../../contexts/AuthContext'
import { toast } from 'sonner'

const NotificationsList: React.FC = () => {
  const { user } = useAuth()
  const { t } = useLanguage()
  const [notifications, setNotifications] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [unreadCount, setUnreadCount] = useState(0)
  
  // åŠ è½½é€šçŸ¥åˆ—è¡¨
  const loadNotifications = useCallback(async () => {
    if (!user) return
    
    try {
      setLoading(true)
      const response = await fetch(`/api/users/${user.id}/notifications?limit=50`)
      const result = await response.json()
      
      if (result.success) {
        setNotifications(result.data.notifications)
        setUnreadCount(result.data.unreadCount)
      }
    } catch (error) {
      console.error('åŠ è½½é€šçŸ¥å¤±è´¥:', error)
      toast.error('åŠ è½½é€šçŸ¥å¤±è´¥')
    } finally {
      setLoading(false)
    }
  }, [user])
  
  // æ ‡è®°å•ä¸ªé€šçŸ¥ä¸ºå·²è¯»
  const markAsRead = async (notificationId: string) => {
    if (!user) return
    
    try {
      const response = await fetch(`/api/users/${user.id}/notifications/${notificationId}/read`, {
        method: 'PUT'
      })
      
      if (response.ok) {
        setNotifications(prev => 
          prev.map(notification => 
            notification.id === notificationId 
              ? { ...notification, read: true }
              : notification
          )
        )
        setUnreadCount(prev => Math.max(0, prev - 1))
      }
    } catch (error) {
      console.error('æ ‡è®°å·²è¯»å¤±è´¥:', error)
      toast.error('æ“ä½œå¤±è´¥')
    }
  }
  
  // å…¨éƒ¨æ ‡è®°ä¸ºå·²è¯»
  const markAllAsRead = async () => {
    if (!user) return
    
    try {
      const response = await fetch(`/api/users/${user.id}/notifications/mark-all-read`, {
        method: 'PUT'
      })
      
      if (response.ok) {
        setNotifications(prev => 
          prev.map(notification => ({ ...notification, read: true }))
        )
        setUnreadCount(0)
        toast.success('æ‰€æœ‰é€šçŸ¥å·²æ ‡è®°ä¸ºå·²è¯»')
      }
    } catch (error) {
      console.error('æ‰¹é‡æ ‡è®°å¤±è´¥:', error)
      toast.error('æ“ä½œå¤±è´¥')
    }
  }
  
  useEffect(() => {
    loadNotifications()
  }, [loadNotifications])
  
  // æ¸²æŸ“UIçš„å…¶ä½™éƒ¨åˆ†ä¿æŒä¸å˜ï¼Œä½†ä½¿ç”¨çœŸå®æ•°æ®...
  // ... ç°æœ‰UIä»£ç  ...
}
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] é€šçŸ¥åˆ—è¡¨æŸ¥è¯¢æ—¶é—´ä»æ¨¡æ‹Ÿæ•°æ®çš„å³æ—¶å“åº”é™è‡³ 100ms çœŸå®æŸ¥è¯¢
- [ ] é€šçŸ¥å®æ—¶æ€§ä¿æŒåœ¨3åˆ†é’Ÿå†…
- [ ] æ”¯æŒå·²è¯»/æœªè¯»çŠ¶æ€çš„ç¼“å­˜
- [ ] é€šçŸ¥æ“ä½œåè‡ªåŠ¨å¤±æ•ˆç›¸å…³ç¼“å­˜

---

### 3. ç¤¾äº¤å…³ç³»ç¼“å­˜ä¼˜åŒ–

#### 3.1 å…³æ³¨/ç²‰ä¸åˆ—è¡¨ç¼“å­˜
**ä¼˜å…ˆçº§**: ğŸ”¥ ä¸­  
**é¢„ä¼°å·¥æ—¶**: 4å°æ—¶  

**å®æ–½æ­¥éª¤**:

##### ç¤¾äº¤å…³ç³»APIï¼ˆå¦‚æœè¿˜æœªå®ç°ï¼‰
```typescript
// api/routes/users/social.ts (æ‰©å±•ç°æœ‰æ–‡ä»¶)
import { userCache } from '../../lib/cacheInstances.js'
import { CacheKeyGenerator, CACHE_TTL } from '../../config/cache.js'

// GET /api/users/:id/followers - è·å–ç²‰ä¸åˆ—è¡¨
router.get('/:id/followers',
  createUserSpecificCacheMiddleware({
    cacheService: userCache,
    keyGenerator: (req) => {
      const { id } = req.params
      const { limit = 20, offset = 0 } = req.query
      return `${CACHE_PREFIXES.USER}${id}:followers:${limit}:${offset}`
    },
    ttl: CACHE_TTL.MEDIUM
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const { id } = req.params
      const { limit = 20, offset = 0 } = req.query
      
      const { data: followers, error } = await supabase
        .from('user_follows')
        .select(`
          follower:follower_id (
            id,
            username,
            full_name,
            avatar_url,
            bio
          ),
          created_at
        `)
        .eq('following_id', id)
        .order('created_at', { ascending: false })
        .range(Number(offset), Number(offset) + Number(limit) - 1)
      
      if (error) throw error
      
      const followersList = followers?.map(item => ({
        ...item.follower,
        followed_at: item.created_at
      })) || []
      
      res.json({
        success: true,
        data: followersList,
        cached: false
      })
      
    } catch (error) {
      console.error('è·å–ç²‰ä¸åˆ—è¡¨å¤±è´¥:', error)
      res.status(500).json({
        success: false,
        error: 'è·å–ç²‰ä¸åˆ—è¡¨å¤±è´¥'
      })
    }
  })
)

// GET /api/users/:id/following - è·å–å…³æ³¨åˆ—è¡¨
router.get('/:id/following',
  createUserSpecificCacheMiddleware({
    cacheService: userCache,
    keyGenerator: (req) => {
      const { id } = req.params
      const { limit = 20, offset = 0 } = req.query
      return `${CACHE_PREFIXES.USER}${id}:following:${limit}:${offset}`
    },
    ttl: CACHE_TTL.MEDIUM
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const { id } = req.params
      const { limit = 20, offset = 0 } = req.query
      
      const { data: following, error } = await supabase
        .from('user_follows')
        .select(`
          following:following_id (
            id,
            username,
            full_name,
            avatar_url,
            bio
          ),
          created_at
        `)
        .eq('follower_id', id)
        .order('created_at', { ascending: false })
        .range(Number(offset), Number(offset) + Number(limit) - 1)
      
      if (error) throw error
      
      const followingList = following?.map(item => ({
        ...item.following,
        followed_at: item.created_at
      })) || []
      
      res.json({
        success: true,
        data: followingList,
        cached: false
      })
      
    } catch (error) {
      console.error('è·å–å…³æ³¨åˆ—è¡¨å¤±è´¥:', error)
      res.status(500).json({
        success: false,
        error: 'è·å–å…³æ³¨åˆ—è¡¨å¤±è´¥'
      })
    }
  })
)
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] ç¤¾äº¤å…³ç³»æŸ¥è¯¢æ—¶é—´ä» 250ms é™è‡³ 40ms
- [ ] æ”¯æŒå…³æ³¨å’Œç²‰ä¸çš„åˆ†åˆ«ç¼“å­˜
- [ ] å…³æ³¨/å–æ¶ˆå…³æ³¨åè‡ªåŠ¨å¤±æ•ˆç›¸å…³ç¼“å­˜

---

## âš¡ é˜¶æ®µä¸‰ï¼šé«˜çº§ä¼˜åŒ–ä¸ç”¨æˆ·ä½“éªŒ (ç¬¬3å‘¨) - ä¸­ç­‰ä¼˜å…ˆçº§

### 4. ä¸ªäººä¸­å¿ƒä»ªè¡¨æ¿ä¼˜åŒ–

#### 4.1 ä¸ªäººä¸­å¿ƒæ¦‚è§ˆæ•°æ®èšåˆç¼“å­˜
**ä¼˜å…ˆçº§**: ğŸ”¥ ä¸­  
**é¢„ä¼°å·¥æ—¶**: 3å°æ—¶  

**å®æ–½æ­¥éª¤**:

##### æ¦‚è§ˆæ•°æ®èšåˆAPI
```typescript
// api/routes/users/dashboard.ts (æ–°å¢æ–‡ä»¶)
export default router

// GET /api/users/:id/dashboard - è·å–ä¸ªäººä¸­å¿ƒæ¦‚è§ˆæ•°æ®
router.get('/:id/dashboard',
  createUserSpecificCacheMiddleware({
    cacheService: statsCache,
    keyGenerator: (req) => `${CACHE_PREFIXES.USER}${req.params.id}:dashboard`,
    ttl: CACHE_TTL.SHORT // 5åˆ†é’Ÿ
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const { id } = req.params
      
      // å¹¶è¡Œè·å–æ¦‚è§ˆæ‰€éœ€çš„æ‰€æœ‰æ•°æ®
      const [
        stats,
        recentPosts,
        recentActivities,
        unreadNotifications
      ] = await Promise.all([
        // å¤ç”¨ç»Ÿè®¡APIçš„é€»è¾‘
        getStatsCacheOrFetch(id),
        
        // æœ€è¿‘5ä¸ªå¸–å­
        supabase
          .from('posts')
          .select('id, title, content, created_at, likes_count, comments_count')
          .eq('user_id', id)
          .eq('status', 'published')
          .order('created_at', { ascending: false })
          .limit(5),
        
        // æœ€è¿‘5ä¸ªæ´»åŠ¨
        supabase
          .from('activity_participants')
          .select(`
            activities!inner(
              id, title, description, start_date, status
            ),
            joined_at
          `)
          .eq('user_id', id)
          .order('joined_at', { ascending: false })
          .limit(5),
        
        // æœªè¯»é€šçŸ¥æ•°é‡
        supabase
          .from('notifications')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', id)
          .eq('read', false)
      ])
      
      const dashboardData = {
        stats,
        recentActivity: {
          posts: recentPosts.data || [],
          activities: recentActivities.data?.map(item => ({
            ...item.activities,
            joined_at: item.joined_at
          })) || []
        },
        unreadNotifications: unreadNotifications.count || 0,
        lastUpdated: new Date().toISOString()
      }
      
      res.json({
        success: true,
        data: dashboardData,
        cached: false
      })
      
    } catch (error) {
      console.error('è·å–ä¸ªäººä¸­å¿ƒæ¦‚è§ˆå¤±è´¥:', error)
      res.status(500).json({
        success: false,
        error: 'è·å–ä¸ªäººä¸­å¿ƒæ¦‚è§ˆå¤±è´¥'
      })
    }
  })
)

// è¾…åŠ©å‡½æ•°
async function getStatsCacheOrFetch(userId: string) {
  const cacheKey = CacheKeyGenerator.userStats(userId)
  let stats = await statsCache.get(cacheKey)
  
  if (!stats) {
    // å¦‚æœç»Ÿè®¡ç¼“å­˜ä¸å­˜åœ¨ï¼Œå¿«é€Ÿè®¡ç®—åŸºæœ¬ç»Ÿè®¡
    const [postsCount, activitiesCount] = await Promise.all([
      supabase.from('posts').select('*', { count: 'exact', head: true }).eq('user_id', userId),
      supabase.from('activity_participants').select('*', { count: 'exact', head: true }).eq('user_id', userId)
    ])
    
    stats = {
      postsCount: postsCount.count || 0,
      activitiesCount: activitiesCount.count || 0,
      // å…¶ä»–ç»Ÿè®¡æ•°æ®å¯ä»¥å»¶è¿ŸåŠ è½½
    }
    
    await statsCache.set(cacheKey, stats, CACHE_TTL.SHORT)
  }
  
  return stats
}
```

##### å‰ç«¯ä¼˜åŒ– - æ¦‚è§ˆé¡µé¢ä½¿ç”¨èšåˆAPI
```typescript
// src/hooks/useUserProfile.ts
// æ·»åŠ æ¦‚è§ˆæ•°æ®åŠ è½½æ–¹æ³•
const loadDashboardData = useCallback(async () => {
  if (!user) return
  
  try {
    const response = await fetch(`/api/users/${user.id}/dashboard`)
    const result = await response.json()
    
    if (result.success) {
      const { stats, recentActivity, unreadNotifications } = result.data
      
      setUserStats(stats)
      setUserPosts(recentActivity.posts)
      setUserActivities(recentActivity.activities)
      
      // å¯ä»¥åœ¨è¿™é‡Œè®¾ç½®æœªè¯»é€šçŸ¥æ•°é‡åˆ°å…¨å±€çŠ¶æ€
      
      setCacheStatus(prev => ({
        ...prev,
        dashboard: result.cached || false
      }))
    }
  } catch (error) {
    console.error('åŠ è½½æ¦‚è§ˆæ•°æ®å¤±è´¥:', error)
    toast.error('åŠ è½½æ¦‚è§ˆæ•°æ®å¤±è´¥')
  }
}, [user])

// åœ¨æ¦‚è§ˆæ ‡ç­¾é¡µæ—¶ä½¿ç”¨ä¼˜åŒ–çš„åŠ è½½æ–¹æ³•
useEffect(() => {
  if (user && activeTab === 'overview') {
    loadDashboardData()
  }
}, [user, activeTab, loadDashboardData])
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] ä¸ªäººä¸­å¿ƒæ¦‚è§ˆé¡µåŠ è½½æ—¶é—´ä» 800ms é™è‡³ 150ms
- [ ] å‡å°‘APIè°ƒç”¨æ¬¡æ•°ä»5-6ä¸ªé™è‡³1ä¸ª
- [ ] æ¦‚è§ˆæ•°æ®å®æ—¶æ€§ä¿æŒåœ¨5åˆ†é’Ÿå†…

---

#### 4.2 ç¼“å­˜å¤±æ•ˆç­–ç•¥ä¼˜åŒ–
**ä¼˜å…ˆçº§**: ğŸ”¥ ä¸­  
**é¢„ä¼°å·¥æ—¶**: 2å°æ—¶  

**å®æ–½æ­¥éª¤**:

##### æ™ºèƒ½ç¼“å­˜å¤±æ•ˆç³»ç»Ÿ
```typescript
// api/services/userCacheInvalidation.ts (æ–°å¢æ–‡ä»¶)
import { userCache, statsCache } from '../lib/cacheInstances.js'
import { CACHE_PREFIXES } from '../config/cache.js'

export class UserCacheInvalidation {
  
  // ç”¨æˆ·å‘å¸ƒå¸–å­åçš„ç¼“å­˜å¤±æ•ˆ
  static async onPostCreated(userId: string) {
    const patterns = [
      `${CACHE_PREFIXES.USER}${userId}:posts:`,
      `${CACHE_PREFIXES.USER}${userId}:dashboard`,
      `${CACHE_PREFIXES.STATS}user:${userId}`
    ]
    
    await this.invalidateByPatterns(patterns)
  }
  
  // ç”¨æˆ·å‚åŠ æ´»åŠ¨åçš„ç¼“å­˜å¤±æ•ˆ
  static async onActivityJoined(userId: string) {
    const patterns = [
      `${CACHE_PREFIXES.USER}${userId}:activities:`,
      `${CACHE_PREFIXES.USER}${userId}:dashboard`,
      `${CACHE_PREFIXES.STATS}user:${userId}`
    ]
    
    await this.invalidateByPatterns(patterns)
  }
  
  // å…³æ³¨/å–æ¶ˆå…³æ³¨çš„ç¼“å­˜å¤±æ•ˆ
  static async onFollowChanged(followerId: string, followingId: string) {
    const patterns = [
      `${CACHE_PREFIXES.USER}${followerId}:following:`,
      `${CACHE_PREFIXES.USER}${followingId}:followers:`,
      `${CACHE_PREFIXES.STATS}user:${followerId}`,
      `${CACHE_PREFIXES.STATS}user:${followingId}`
    ]
    
    await this.invalidateByPatterns(patterns)
  }
  
  // é€šçŸ¥ç›¸å…³ç¼“å­˜å¤±æ•ˆ
  static async onNotificationChanged(userId: string) {
    const patterns = [
      `${CACHE_PREFIXES.USER}${userId}:notifications:`,
      `${CACHE_PREFIXES.USER}${userId}:dashboard`
    ]
    
    await this.invalidateByPatterns(patterns)
  }
  
  // æŒ‰æ¨¡å¼æ‰¹é‡æ¸…ç†ç¼“å­˜
  private static async invalidateByPatterns(patterns: string[]) {
    try {
      for (const pattern of patterns) {
        // ä»userCacheæ¸…ç†
        const userKeys = userCache.keys().filter(key => key.includes(pattern))
        if (userKeys.length > 0) {
          await userCache.mdel(userKeys)
        }
        
        // ä»statsCacheæ¸…ç†
        const statsKeys = statsCache.keys().filter(key => key.includes(pattern))
        if (statsKeys.length > 0) {
          await statsCache.mdel(statsKeys)
        }
      }
      
      console.log(`ç¼“å­˜æ¸…ç†å®Œæˆï¼Œæ¨¡å¼: ${patterns.join(', ')}`)
    } catch (error) {
      console.error('ç¼“å­˜æ¸…ç†å¤±è´¥:', error)
    }
  }
}
```

##### åœ¨ç›¸å…³APIä¸­é›†æˆæ™ºèƒ½å¤±æ•ˆ
```typescript
// åœ¨å‘å¸ƒå¸–å­çš„APIä¸­
router.post('/posts', asyncHandler(async (req, res) => {
  // ... å‘å¸ƒå¸–å­é€»è¾‘ ...
  
  if (success) {
    // æ™ºèƒ½ç¼“å­˜å¤±æ•ˆ
    await UserCacheInvalidation.onPostCreated(userId)
  }
  
  // ... è¿”å›å“åº” ...
}))

// åœ¨å‚åŠ æ´»åŠ¨çš„APIä¸­
router.post('/activities/:id/join', asyncHandler(async (req, res) => {
  // ... å‚åŠ æ´»åŠ¨é€»è¾‘ ...
  
  if (success) {
    await UserCacheInvalidation.onActivityJoined(userId)
  }
  
  // ... è¿”å›å“åº” ...
}))
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] ç”¨æˆ·æ“ä½œåç›¸å…³ç¼“å­˜5ç§’å†…è‡ªåŠ¨å¤±æ•ˆ
- [ ] ç¼“å­˜å¤±æ•ˆä¸å½±å“APIå“åº”æ—¶é—´
- [ ] æ”¯æŒçº§è”æ¸…ç†ç›¸å…³ç¼“å­˜

---

## ğŸ“Š é¡¹ç›®éªŒæ”¶æ ‡å‡†

### æ•´ä½“æ€§èƒ½ç›®æ ‡
- [ ] **ä¸ªäººä¸­å¿ƒåŠ è½½é€Ÿåº¦æå‡**: 70% (ä»å¹³å‡800msé™è‡³200ms)
- [ ] **ç¼“å­˜å‘½ä¸­ç‡**: æ•´ä½“80%ä»¥ä¸Šï¼Œæ ¸å¿ƒæ¨¡å—85%ä»¥ä¸Š  
- [ ] **APIè°ƒç”¨å‡å°‘**: 60-75%
- [ ] **ç”¨æˆ·ä½“éªŒ**: é¡µé¢åˆ‡æ¢æ›´æµç•…ï¼Œæ•°æ®åŠ è½½æ›´å¿«

### å„æ¨¡å—å…·ä½“ç›®æ ‡

#### å¸–å­ç®¡ç†æ¨¡å—
- [ ] ç”¨æˆ·å¸–å­åˆ—è¡¨æŸ¥è¯¢: 300ms â†’ 50ms
- [ ] å¸–å­ç»Ÿè®¡æŸ¥è¯¢: 400ms â†’ 60ms
- [ ] ç¼“å­˜å‘½ä¸­ç‡: 80%ä»¥ä¸Š

#### æ´»åŠ¨ç®¡ç†æ¨¡å—
- [ ] æ´»åŠ¨åˆ—è¡¨æŸ¥è¯¢: 400ms â†’ 60ms  
- [ ] å‚ä¸æ´»åŠ¨æŸ¥è¯¢: 350ms â†’ 55ms
- [ ] ç¼“å­˜å‘½ä¸­ç‡: 75%ä»¥ä¸Š

#### é€šçŸ¥ç³»ç»Ÿ
- [ ] é€šçŸ¥åˆ—è¡¨æŸ¥è¯¢: âˆ (æ¨¡æ‹Ÿæ•°æ®) â†’ 100ms
- [ ] é€šçŸ¥å®æ—¶æ€§: 3åˆ†é’Ÿå†…
- [ ] ç¼“å­˜å‘½ä¸­ç‡: 70%ä»¥ä¸Š

#### ä¸ªäººä¸­å¿ƒæ¦‚è§ˆ
- [ ] æ¦‚è§ˆé¡µåŠ è½½: 800ms â†’ 150ms
- [ ] APIè°ƒç”¨å‡å°‘: 6ä¸ª â†’ 1ä¸ª
- [ ] æ•°æ®èšåˆæ•ˆç‡: æå‡80%

---

## ğŸ› ï¸ å®æ–½æ—¶é—´å®‰æ’

### ç¬¬ä¸€å‘¨ (æ ¸å¿ƒæ•°æ®ç¼“å­˜)
- **å‘¨ä¸€-å‘¨äºŒ**: ä»»åŠ¡1.1-1.2 ç”¨æˆ·å¸–å­å’Œæ´»åŠ¨åˆ—è¡¨ç¼“å­˜ (6h)
- **å‘¨ä¸‰**: ä»»åŠ¡1.3 ç”¨æˆ·ç»Ÿè®¡æ•°æ®ä¼˜åŒ– (2h)
- **å‘¨å››-å‘¨äº”**: æµ‹è¯•å’Œä¼˜åŒ–æ ¸å¿ƒç¼“å­˜åŠŸèƒ½

### ç¬¬äºŒå‘¨ (é€šçŸ¥ä¸ç¤¾äº¤åŠŸèƒ½)  
- **å‘¨ä¸€-å‘¨ä¸‰**: ä»»åŠ¡2.1 é€šçŸ¥ç³»ç»Ÿå®Œæ•´å®ç° (5h)
- **å‘¨å››**: ä»»åŠ¡3.1 ç¤¾äº¤å…³ç³»ç¼“å­˜ (4h)
- **å‘¨äº”**: é›†æˆæµ‹è¯•å’Œé—®é¢˜ä¿®å¤

### ç¬¬ä¸‰å‘¨ (é«˜çº§ä¼˜åŒ–)
- **å‘¨ä¸€-å‘¨äºŒ**: ä»»åŠ¡4.1 æ¦‚è§ˆæ•°æ®èšåˆç¼“å­˜ (3h)  
- **å‘¨ä¸‰**: ä»»åŠ¡4.2 æ™ºèƒ½ç¼“å­˜å¤±æ•ˆä¼˜åŒ– (2h)
- **å‘¨å››**: å…¨é¢æ€§èƒ½æµ‹è¯•å’Œè°ƒä¼˜
- **å‘¨äº”**: ç”¨æˆ·ä½“éªŒæµ‹è¯•å’Œæ–‡æ¡£æ›´æ–°

---

## ğŸš¨ é£é™©è¯„ä¼°å’Œåº”å¯¹ç­–ç•¥

### æŠ€æœ¯é£é™©
1. **é€šçŸ¥ç³»ç»Ÿå¤æ‚æ€§**: éœ€è¦å®æ—¶æ€§å’Œç¼“å­˜å¹³è¡¡
2. **ç¼“å­˜ä¸€è‡´æ€§**: ç¤¾äº¤å…³ç³»å˜åŒ–çš„çº§è”æ›´æ–°
3. **å‰ç«¯çŠ¶æ€ç®¡ç†**: å¤šæ ‡ç­¾é¡µæ•°æ®åŒæ­¥

### åº”å¯¹ç­–ç•¥
1. **åˆ†å±‚ç¼“å­˜**: é€šçŸ¥ä½¿ç”¨çŸ­TTLï¼Œç»Ÿè®¡æ•°æ®ä½¿ç”¨é•¿TTL
2. **æ™ºèƒ½å¤±æ•ˆ**: å®æ–½ç²¾ç¡®çš„ç¼“å­˜æ¸…ç†ç­–ç•¥  
3. **çŠ¶æ€åŒæ­¥**: ä½¿ç”¨React Contextå’Œç¼“å­˜çŠ¶æ€ç®¡ç†

---

## ğŸ“ˆ æˆåŠŸæŒ‡æ ‡ç›‘æ§

### å®æ—¶ç›‘æ§æŒ‡æ ‡
- [ ] ä¸ªäººä¸­å¿ƒå„æ ‡ç­¾é¡µå“åº”æ—¶é—´
- [ ] ç¼“å­˜å‘½ä¸­ç‡åˆ†æ
- [ ] ç”¨æˆ·æ“ä½œåç¼“å­˜å¤±æ•ˆå‡†ç¡®æ€§

### ç”¨æˆ·ä½“éªŒæŒ‡æ ‡
- [ ] é¡µé¢åˆ‡æ¢æµç•…åº¦
- [ ] æ•°æ®åŠ è½½ç­‰å¾…æ—¶é—´  
- [ ] ç¼“å­˜æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥

---

## ğŸ¯ é¡¹ç›®æ€»ç»“

è¿™ä¸ªå‰å°ä¸ªäººä¸­å¿ƒç¼“å­˜ä¼˜åŒ–æ–¹æ¡ˆå°†æ˜¾è‘—æå‡ç”¨æˆ·ä½“éªŒï¼š

1. **æ€§èƒ½å¤§å¹…æå‡**: ä¸ªäººä¸­å¿ƒå“åº”é€Ÿåº¦æå‡70%
2. **åŠŸèƒ½å®Œå–„**: ä»æ¨¡æ‹Ÿé€šçŸ¥åˆ°å®Œæ•´é€šçŸ¥ç³»ç»Ÿ
3. **æ™ºèƒ½ç¼“å­˜**: è‡ªåŠ¨å¤±æ•ˆå’Œæ•°æ®ä¸€è‡´æ€§ä¿è¯  
4. **ç”¨æˆ·ä½“éªŒ**: æµç•…çš„é¡µé¢åˆ‡æ¢å’Œå¿«é€Ÿçš„æ•°æ®åŠ è½½

é€šè¿‡3å‘¨çš„ç³»ç»ŸåŒ–å®æ–½ï¼Œç”¨æˆ·çš„ä¸ªäººä¸­å¿ƒå°†ä»åŸºç¡€åŠŸèƒ½å‡çº§ä¸ºé«˜æ€§èƒ½ã€åŠŸèƒ½å®Œå–„çš„ç”¨æˆ·ç®¡ç†å¹³å°ï¼âœ¨
