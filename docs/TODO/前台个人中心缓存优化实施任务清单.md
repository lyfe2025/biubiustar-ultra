# 前台个人中心缓存优化实施任务清单

## 📊 项目概览

**项目名称**: 前台个人中心缓存系统优化  
**当前缓存覆盖率**: < 20%  
**目标缓存覆盖率**: 85%+  
**预期性能提升**: 个人中心页面加载速度提升70%，从800ms降至200ms  
**实施周期**: 3周  

---

## 🔍 当前状况分析

### ✅ 已实现缓存的模块
1. **用户资料查询** - `GET /api/users/:id/profile`
   - 缓存实例: `userCache`
   - TTL: 默认中等时长
   - 状态: ✅ 已实现

2. **头像上传** - `POST /api/users/avatar`
   - 缓存失效: ✅ 已实现自动失效机制

### ❌ 未实现缓存的模块
1. **用户帖子列表** - `GET /api/users/:id/posts`
2. **用户活动列表** - `GET /api/users/:id/activities` 
3. **用户创建的活动** - `GET /api/users/:id/created-activities`
4. **用户统计数据** - 前端计算，需要API缓存支持
5. **通知系统** - 目前为模拟数据，需要完整实现
6. **社交关系** - 关注/粉丝列表等

---

## 🎯 阶段一：核心数据缓存 (第1周) - 高优先级

### 1. 用户帖子列表缓存优化

#### 1.1 用户帖子查询缓存
**优先级**: 🔥 最高  
**预估工时**: 3小时  
**文件涉及**: `api/routes/users/posts.ts`, `src/hooks/useUserProfile.ts`

**实施步骤**:

##### 后端API缓存实现
```typescript
// api/routes/users/posts.ts
import { userCache } from '../../lib/cacheInstances.js'
import { CacheKeyGenerator, CACHE_TTL } from '../../config/cache.js'
import { createUserSpecificCacheMiddleware } from '../../middleware/cache.js'

// 添加缓存中间件到现有路由
router.get('/:id/posts', 
  createUserSpecificCacheMiddleware({
    cacheService: userCache,
    keyGenerator: (req) => {
      const { id } = req.params
      const { limit = 10, offset = 0, category, status } = req.query
      return CacheKeyGenerator.userPosts(id, {
        limit: Number(limit),
        offset: Number(offset),
        category: category as string,
        status: status as string
      })
    },
    ttl: CACHE_TTL.MEDIUM // 10分钟
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    // 现有逻辑保持不变，中间件会自动处理缓存
    // ... 现有代码 ...
  })
)
```

##### 缓存键生成器扩展
```typescript
// api/config/cache.ts
export class CacheKeyGenerator {
  // ... 现有方法 ...
  
  // 用户个人中心相关缓存键
  static userPosts(userId: string, options: {
    limit: number;
    offset: number;
    category?: string;
    status?: string;
  }): string {
    const params = JSON.stringify(options)
    return `${CACHE_PREFIXES.USER}${userId}:posts:${params}`
  }
  
  static userActivities(userId: string, options: {
    limit: number;
    offset: number;
    category?: string;
    status?: string;
  }): string {
    const params = JSON.stringify(options)
    return `${CACHE_PREFIXES.USER}${userId}:activities:${params}`
  }
  
  static userCreatedActivities(userId: string, options: {
    limit: number;
    offset: number;
    category?: string;
    status?: string;
  }): string {
    const params = JSON.stringify(options)
    return `${CACHE_PREFIXES.USER}${userId}:created_activities:${params}`
  }
  
  static userStats(userId: string): string {
    return `${CACHE_PREFIXES.STATS}user:${userId}`
  }
  
  static userNotifications(userId: string, options: {
    limit?: number;
    offset?: number;
    unreadOnly?: boolean;
  } = {}): string {
    const params = JSON.stringify(options)
    return `${CACHE_PREFIXES.USER}${userId}:notifications:${params}`
  }
}
```

##### 前端优化 - useUserProfile Hook
```typescript
// src/hooks/useUserProfile.ts 
// 在现有基础上添加缓存感知逻辑

export const useUserProfile = () => {
  // ... 现有状态 ...
  
  // 新增缓存状态
  const [cacheStatus, setCacheStatus] = useState<{
    posts: boolean;
    activities: boolean;
    profile: boolean;
    stats: boolean;
  }>({
    posts: false,
    activities: false,
    profile: false,
    stats: false
  })

  // 优化加载用户数据函数
  const loadUserData = useCallback(async () => {
    if (!user) return
    
    try {
      setIsLoading(true)
      
      // 并行加载所有数据，利用缓存
      const [profile, postsResponse, activities] = await Promise.all([
        socialService.getUserProfile(user.id),
        socialService.getUserPosts(user.id),
        ActivityService.getUserActivities(user.id)
      ])
      
      // 检查缓存命中状态（如果API返回缓存标识）
      setCacheStatus({
        profile: profile?.cached || false,
        posts: postsResponse?.cached || false,
        activities: activities?.cached || false,
        stats: false // 统计数据由前端计算
      })
      
      setUserProfile(profile)
      
      const posts = Array.isArray(postsResponse) ? postsResponse : postsResponse.posts || []
      setUserPosts(posts)
      setUserActivities(activities)
      
      // 缓存统计数据计算结果
      const stats = {
        postsCount: posts.length,
        followersCount: profile?.followers_count || 0,
        followingCount: profile?.following_count || 0,
        likes: posts.reduce((sum: number, post: any) => sum + (post.likes_count || 0), 0)
      }
      setUserStats(stats)
      
    } catch (error) {
      console.error('加载用户数据失败:', error)
      toast.error('加载用户数据失败')
    } finally {
      setIsLoading(false)
    }
  }, [user])
  
  // 添加强制刷新方法（跳过缓存）
  const forceRefreshData = useCallback(async () => {
    if (!user) return
    
    try {
      setIsLoading(true)
      
      // 添加cache-control header强制跳过缓存
      const headers = { 'Cache-Control': 'no-cache' }
      
      const [profile, postsResponse, activities] = await Promise.all([
        fetch(`/api/users/${user.id}/profile`, { headers }).then(r => r.json()),
        fetch(`/api/users/${user.id}/posts?limit=100`, { headers }).then(r => r.json()),
        fetch(`/api/users/${user.id}/activities?limit=100`, { headers }).then(r => r.json())
      ])
      
      // 更新所有状态...
      // ... 处理逻辑 ...
      
    } catch (error) {
      console.error('强制刷新失败:', error)
      toast.error('刷新失败')
    } finally {
      setIsLoading(false)
    }
  }, [user])

  return {
    // ... 现有返回值 ...
    cacheStatus,
    forceRefreshData
  }
}
```

**验收标准**:
- [ ] 用户帖子查询时间从 300ms 降至 50ms
- [ ] 缓存命中率达到 80%以上
- [ ] 前端显示缓存状态指示器
- [ ] 支持分页和筛选的缓存

---

#### 1.2 用户活动列表缓存
**优先级**: 🔥 高  
**预估工时**: 3小时  

**实施步骤**:

##### 参与活动列表缓存
```typescript
// api/routes/users/posts.ts (在现有GET /:id/activities路由上添加缓存)
router.get('/:id/activities',
  createUserSpecificCacheMiddleware({
    cacheService: userCache,
    keyGenerator: (req) => {
      const { id } = req.params
      const { limit = 10, offset = 0, category, status = 'published' } = req.query
      return CacheKeyGenerator.userActivities(id, {
        limit: Number(limit),
        offset: Number(offset),
        category: category as string,
        status: status as string
      })
    },
    ttl: CACHE_TTL.MEDIUM
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    // 现有逻辑保持不变
    // ... 现有代码 ...
  })
)

// 创建活动列表缓存
router.get('/:id/created-activities',
  createUserSpecificCacheMiddleware({
    cacheService: userCache,
    keyGenerator: (req) => {
      const { id } = req.params
      const { limit = 10, offset = 0, category, status = 'published' } = req.query
      return CacheKeyGenerator.userCreatedActivities(id, {
        limit: Number(limit),
        offset: Number(offset),
        category: category as string,
        status: status as string
      })
    },
    ttl: CACHE_TTL.MEDIUM
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    // 现有逻辑保持不变
    // ... 现有代码 ...
  })
)
```

**验收标准**:
- [ ] 活动列表查询时间从 400ms 降至 60ms
- [ ] 支持参与活动和创建活动的分别缓存
- [ ] 缓存命中率达到 75%以上

---

#### 1.3 用户统计数据优化
**优先级**: 🔥 中  
**预估工时**: 2小时  

**实施步骤**:

##### 新建用户统计API
```typescript
// api/routes/users/stats.ts (新增文件)
import { Router, Request, Response } from 'express'
import { supabase } from '../../lib/supabase'
import { statsCache } from '../../lib/cacheInstances.js'
import { CacheKeyGenerator, CACHE_TTL } from '../../config/cache.js'
import { createUserSpecificCacheMiddleware } from '../../middleware/cache.js'
import asyncHandler from '../../middleware/asyncHandler.js'

const router = Router()

// GET /api/users/:id/stats - 获取用户统计数据
router.get('/:id/stats',
  createUserSpecificCacheMiddleware({
    cacheService: statsCache,
    keyGenerator: (req) => CacheKeyGenerator.userStats(req.params.id),
    ttl: CACHE_TTL.SHORT // 5分钟，保持数据较新
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const { id } = req.params
      
      // 并行获取各种统计数据
      const [
        { count: postsCount },
        { count: activitiesCount },
        { count: createdActivitiesCount },
        { data: socialData }
      ] = await Promise.all([
        // 帖子数量
        supabase
          .from('posts')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', id)
          .eq('status', 'published'),
        
        // 参与活动数量
        supabase
          .from('activity_participants')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', id),
        
        // 创建活动数量
        supabase
          .from('activities')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', id)
          .eq('status', 'published'),
        
        // 社交数据（关注、粉丝、点赞）
        supabase
          .from('user_profiles')
          .select('followers_count, following_count')
          .eq('id', id)
          .single()
      ])
      
      // 计算总获赞数
      const { data: posts } = await supabase
        .from('posts')
        .select('likes_count')
        .eq('user_id', id)
      
      const totalLikes = posts?.reduce((sum, post) => sum + (post.likes_count || 0), 0) || 0
      
      const statsData = {
        postsCount: postsCount || 0,
        activitiesCount: activitiesCount || 0,
        createdActivitiesCount: createdActivitiesCount || 0,
        followersCount: socialData?.followers_count || 0,
        followingCount: socialData?.following_count || 0,
        totalLikes,
        lastUpdated: new Date().toISOString()
      }
      
      res.json({
        success: true,
        data: statsData,
        cached: false
      })
      
    } catch (error) {
      console.error('获取用户统计失败:', error)
      res.status(500).json({
        success: false,
        error: '获取用户统计失败'
      })
    }
  })
)

export default router
```

##### 集成到主路由
```typescript
// api/routes/users/index.ts
import statsRoutes from './stats.js'

// 添加统计路由
router.use('/', statsRoutes)
```

##### 前端使用优化统计API
```typescript
// src/hooks/useUserProfile.ts
const loadUserData = useCallback(async () => {
  if (!user) return
  
  try {
    setIsLoading(true)
    
    // 使用专门的统计API，而不是前端计算
    const [profile, postsResponse, activities, stats] = await Promise.all([
      socialService.getUserProfile(user.id),
      socialService.getUserPosts(user.id),
      ActivityService.getUserActivities(user.id),
      fetch(`/api/users/${user.id}/stats`).then(r => r.json()) // 新增统计API调用
    ])
    
    // 设置统计数据
    if (stats.success) {
      setUserStats(stats.data)
    }
    
    // ... 其他处理逻辑 ...
    
  } catch (error) {
    console.error('加载用户数据失败:', error)
    toast.error('加载用户数据失败')
  } finally {
    setIsLoading(false)
  }
}, [user])
```

**验收标准**:
- [ ] 统计数据查询时间从 600ms 降至 80ms  
- [ ] 统计数据实时性保持在5分钟内
- [ ] 支持多维度统计（帖子、活动、社交等）

---

## 🚀 阶段二：通知与社交功能缓存 (第2周) - 中优先级

### 2. 通知系统完整实现与缓存

#### 2.1 通知API实现与缓存
**优先级**: 🔥 中  
**预估工时**: 5小时  

**实施步骤**:

##### 通知数据表设计（如果还未创建）
```sql
-- supabase/migrations/create_notifications_table.sql
CREATE TABLE IF NOT EXISTS notifications (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  type VARCHAR(50) NOT NULL, -- 'like', 'comment', 'follow', 'activity', 'system'
  title VARCHAR(255) NOT NULL,
  message TEXT NOT NULL,
  data JSONB, -- 相关数据，如post_id, comment_id等
  read BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_notifications_user_id ON notifications(user_id);
CREATE INDEX idx_notifications_read ON notifications(read);
CREATE INDEX idx_notifications_created_at ON notifications(created_at DESC);
```

##### 通知API实现
```typescript
// api/routes/users/notifications.ts (新增文件)
import { Router, Request, Response } from 'express'
import { supabaseAdmin } from '../../lib/supabase.js'
import { userCache } from '../../lib/cacheInstances.js'
import { CacheKeyGenerator, CACHE_TTL } from '../../config/cache.js'
import { createUserSpecificCacheMiddleware } from '../../middleware/cache.js'
import asyncHandler from '../../middleware/asyncHandler.js'

const router = Router()

// GET /api/users/:id/notifications - 获取用户通知列表
router.get('/:id/notifications',
  createUserSpecificCacheMiddleware({
    cacheService: userCache,
    keyGenerator: (req) => {
      const { id } = req.params
      const { limit = 20, offset = 0, unreadOnly = false } = req.query
      return CacheKeyGenerator.userNotifications(id, {
        limit: Number(limit),
        offset: Number(offset),
        unreadOnly: unreadOnly === 'true'
      })
    },
    ttl: CACHE_TTL.SHORT // 3分钟，通知需要较高实时性
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const { id } = req.params
      const { limit = 20, offset = 0, unreadOnly = false } = req.query
      
      let query = supabaseAdmin
        .from('notifications')
        .select('*')
        .eq('user_id', id)
        .order('created_at', { ascending: false })
        .range(Number(offset), Number(offset) + Number(limit) - 1)
      
      if (unreadOnly === 'true') {
        query = query.eq('read', false)
      }
      
      const { data: notifications, error, count } = await query
      
      if (error) {
        throw error
      }
      
      // 获取未读数量
      const { count: unreadCount } = await supabaseAdmin
        .from('notifications')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', id)
        .eq('read', false)
      
      res.json({
        success: true,
        data: {
          notifications: notifications || [],
          total: count || 0,
          unreadCount: unreadCount || 0
        },
        cached: false
      })
      
    } catch (error) {
      console.error('获取用户通知失败:', error)
      res.status(500).json({
        success: false,
        error: '获取用户通知失败'
      })
    }
  })
)

// PUT /api/users/:id/notifications/:notificationId/read - 标记通知为已读
router.put('/:id/notifications/:notificationId/read',
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const { id, notificationId } = req.params
      
      const { error } = await supabaseAdmin
        .from('notifications')
        .update({ 
          read: true,
          updated_at: new Date().toISOString()
        })
        .eq('id', notificationId)
        .eq('user_id', id)
      
      if (error) {
        throw error
      }
      
      // 清除相关缓存
      const cacheKeys = userCache.keys().filter(key => 
        key.includes(`user:${id}:notifications`)
      )
      await userCache.mdel(cacheKeys)
      
      res.json({
        success: true,
        message: '通知已标记为已读'
      })
      
    } catch (error) {
      console.error('标记通知已读失败:', error)
      res.status(500).json({
        success: false,
        error: '标记通知已读失败'
      })
    }
  })
)

// PUT /api/users/:id/notifications/mark-all-read - 全部标记为已读
router.put('/:id/notifications/mark-all-read',
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const { id } = req.params
      
      const { error } = await supabaseAdmin
        .from('notifications')
        .update({ 
          read: true,
          updated_at: new Date().toISOString()
        })
        .eq('user_id', id)
        .eq('read', false)
      
      if (error) {
        throw error
      }
      
      // 清除相关缓存
      const cacheKeys = userCache.keys().filter(key => 
        key.includes(`user:${id}:notifications`)
      )
      await userCache.mdel(cacheKeys)
      
      res.json({
        success: true,
        message: '所有通知已标记为已读'
      })
      
    } catch (error) {
      console.error('全部标记已读失败:', error)
      res.status(500).json({
        success: false,
        error: '全部标记已读失败'
      })
    }
  })
)

export default router
```

##### 前端NotificationsList组件重构
```typescript
// src/pages/profile/NotificationsList.tsx
import React, { useState, useEffect } from 'react'
import { useAuth } from '../../contexts/AuthContext'
import { toast } from 'sonner'

const NotificationsList: React.FC = () => {
  const { user } = useAuth()
  const { t } = useLanguage()
  const [notifications, setNotifications] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [unreadCount, setUnreadCount] = useState(0)
  
  // 加载通知列表
  const loadNotifications = useCallback(async () => {
    if (!user) return
    
    try {
      setLoading(true)
      const response = await fetch(`/api/users/${user.id}/notifications?limit=50`)
      const result = await response.json()
      
      if (result.success) {
        setNotifications(result.data.notifications)
        setUnreadCount(result.data.unreadCount)
      }
    } catch (error) {
      console.error('加载通知失败:', error)
      toast.error('加载通知失败')
    } finally {
      setLoading(false)
    }
  }, [user])
  
  // 标记单个通知为已读
  const markAsRead = async (notificationId: string) => {
    if (!user) return
    
    try {
      const response = await fetch(`/api/users/${user.id}/notifications/${notificationId}/read`, {
        method: 'PUT'
      })
      
      if (response.ok) {
        setNotifications(prev => 
          prev.map(notification => 
            notification.id === notificationId 
              ? { ...notification, read: true }
              : notification
          )
        )
        setUnreadCount(prev => Math.max(0, prev - 1))
      }
    } catch (error) {
      console.error('标记已读失败:', error)
      toast.error('操作失败')
    }
  }
  
  // 全部标记为已读
  const markAllAsRead = async () => {
    if (!user) return
    
    try {
      const response = await fetch(`/api/users/${user.id}/notifications/mark-all-read`, {
        method: 'PUT'
      })
      
      if (response.ok) {
        setNotifications(prev => 
          prev.map(notification => ({ ...notification, read: true }))
        )
        setUnreadCount(0)
        toast.success('所有通知已标记为已读')
      }
    } catch (error) {
      console.error('批量标记失败:', error)
      toast.error('操作失败')
    }
  }
  
  useEffect(() => {
    loadNotifications()
  }, [loadNotifications])
  
  // 渲染UI的其余部分保持不变，但使用真实数据...
  // ... 现有UI代码 ...
}
```

**验收标准**:
- [ ] 通知列表查询时间从模拟数据的即时响应降至 100ms 真实查询
- [ ] 通知实时性保持在3分钟内
- [ ] 支持已读/未读状态的缓存
- [ ] 通知操作后自动失效相关缓存

---

### 3. 社交关系缓存优化

#### 3.1 关注/粉丝列表缓存
**优先级**: 🔥 中  
**预估工时**: 4小时  

**实施步骤**:

##### 社交关系API（如果还未实现）
```typescript
// api/routes/users/social.ts (扩展现有文件)
import { userCache } from '../../lib/cacheInstances.js'
import { CacheKeyGenerator, CACHE_TTL } from '../../config/cache.js'

// GET /api/users/:id/followers - 获取粉丝列表
router.get('/:id/followers',
  createUserSpecificCacheMiddleware({
    cacheService: userCache,
    keyGenerator: (req) => {
      const { id } = req.params
      const { limit = 20, offset = 0 } = req.query
      return `${CACHE_PREFIXES.USER}${id}:followers:${limit}:${offset}`
    },
    ttl: CACHE_TTL.MEDIUM
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const { id } = req.params
      const { limit = 20, offset = 0 } = req.query
      
      const { data: followers, error } = await supabase
        .from('user_follows')
        .select(`
          follower:follower_id (
            id,
            username,
            full_name,
            avatar_url,
            bio
          ),
          created_at
        `)
        .eq('following_id', id)
        .order('created_at', { ascending: false })
        .range(Number(offset), Number(offset) + Number(limit) - 1)
      
      if (error) throw error
      
      const followersList = followers?.map(item => ({
        ...item.follower,
        followed_at: item.created_at
      })) || []
      
      res.json({
        success: true,
        data: followersList,
        cached: false
      })
      
    } catch (error) {
      console.error('获取粉丝列表失败:', error)
      res.status(500).json({
        success: false,
        error: '获取粉丝列表失败'
      })
    }
  })
)

// GET /api/users/:id/following - 获取关注列表
router.get('/:id/following',
  createUserSpecificCacheMiddleware({
    cacheService: userCache,
    keyGenerator: (req) => {
      const { id } = req.params
      const { limit = 20, offset = 0 } = req.query
      return `${CACHE_PREFIXES.USER}${id}:following:${limit}:${offset}`
    },
    ttl: CACHE_TTL.MEDIUM
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const { id } = req.params
      const { limit = 20, offset = 0 } = req.query
      
      const { data: following, error } = await supabase
        .from('user_follows')
        .select(`
          following:following_id (
            id,
            username,
            full_name,
            avatar_url,
            bio
          ),
          created_at
        `)
        .eq('follower_id', id)
        .order('created_at', { ascending: false })
        .range(Number(offset), Number(offset) + Number(limit) - 1)
      
      if (error) throw error
      
      const followingList = following?.map(item => ({
        ...item.following,
        followed_at: item.created_at
      })) || []
      
      res.json({
        success: true,
        data: followingList,
        cached: false
      })
      
    } catch (error) {
      console.error('获取关注列表失败:', error)
      res.status(500).json({
        success: false,
        error: '获取关注列表失败'
      })
    }
  })
)
```

**验收标准**:
- [ ] 社交关系查询时间从 250ms 降至 40ms
- [ ] 支持关注和粉丝的分别缓存
- [ ] 关注/取消关注后自动失效相关缓存

---

## ⚡ 阶段三：高级优化与用户体验 (第3周) - 中等优先级

### 4. 个人中心仪表板优化

#### 4.1 个人中心概览数据聚合缓存
**优先级**: 🔥 中  
**预估工时**: 3小时  

**实施步骤**:

##### 概览数据聚合API
```typescript
// api/routes/users/dashboard.ts (新增文件)
export default router

// GET /api/users/:id/dashboard - 获取个人中心概览数据
router.get('/:id/dashboard',
  createUserSpecificCacheMiddleware({
    cacheService: statsCache,
    keyGenerator: (req) => `${CACHE_PREFIXES.USER}${req.params.id}:dashboard`,
    ttl: CACHE_TTL.SHORT // 5分钟
  }),
  asyncHandler(async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const { id } = req.params
      
      // 并行获取概览所需的所有数据
      const [
        stats,
        recentPosts,
        recentActivities,
        unreadNotifications
      ] = await Promise.all([
        // 复用统计API的逻辑
        getStatsCacheOrFetch(id),
        
        // 最近5个帖子
        supabase
          .from('posts')
          .select('id, title, content, created_at, likes_count, comments_count')
          .eq('user_id', id)
          .eq('status', 'published')
          .order('created_at', { ascending: false })
          .limit(5),
        
        // 最近5个活动
        supabase
          .from('activity_participants')
          .select(`
            activities!inner(
              id, title, description, start_date, status
            ),
            joined_at
          `)
          .eq('user_id', id)
          .order('joined_at', { ascending: false })
          .limit(5),
        
        // 未读通知数量
        supabase
          .from('notifications')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', id)
          .eq('read', false)
      ])
      
      const dashboardData = {
        stats,
        recentActivity: {
          posts: recentPosts.data || [],
          activities: recentActivities.data?.map(item => ({
            ...item.activities,
            joined_at: item.joined_at
          })) || []
        },
        unreadNotifications: unreadNotifications.count || 0,
        lastUpdated: new Date().toISOString()
      }
      
      res.json({
        success: true,
        data: dashboardData,
        cached: false
      })
      
    } catch (error) {
      console.error('获取个人中心概览失败:', error)
      res.status(500).json({
        success: false,
        error: '获取个人中心概览失败'
      })
    }
  })
)

// 辅助函数
async function getStatsCacheOrFetch(userId: string) {
  const cacheKey = CacheKeyGenerator.userStats(userId)
  let stats = await statsCache.get(cacheKey)
  
  if (!stats) {
    // 如果统计缓存不存在，快速计算基本统计
    const [postsCount, activitiesCount] = await Promise.all([
      supabase.from('posts').select('*', { count: 'exact', head: true }).eq('user_id', userId),
      supabase.from('activity_participants').select('*', { count: 'exact', head: true }).eq('user_id', userId)
    ])
    
    stats = {
      postsCount: postsCount.count || 0,
      activitiesCount: activitiesCount.count || 0,
      // 其他统计数据可以延迟加载
    }
    
    await statsCache.set(cacheKey, stats, CACHE_TTL.SHORT)
  }
  
  return stats
}
```

##### 前端优化 - 概览页面使用聚合API
```typescript
// src/hooks/useUserProfile.ts
// 添加概览数据加载方法
const loadDashboardData = useCallback(async () => {
  if (!user) return
  
  try {
    const response = await fetch(`/api/users/${user.id}/dashboard`)
    const result = await response.json()
    
    if (result.success) {
      const { stats, recentActivity, unreadNotifications } = result.data
      
      setUserStats(stats)
      setUserPosts(recentActivity.posts)
      setUserActivities(recentActivity.activities)
      
      // 可以在这里设置未读通知数量到全局状态
      
      setCacheStatus(prev => ({
        ...prev,
        dashboard: result.cached || false
      }))
    }
  } catch (error) {
    console.error('加载概览数据失败:', error)
    toast.error('加载概览数据失败')
  }
}, [user])

// 在概览标签页时使用优化的加载方法
useEffect(() => {
  if (user && activeTab === 'overview') {
    loadDashboardData()
  }
}, [user, activeTab, loadDashboardData])
```

**验收标准**:
- [ ] 个人中心概览页加载时间从 800ms 降至 150ms
- [ ] 减少API调用次数从5-6个降至1个
- [ ] 概览数据实时性保持在5分钟内

---

#### 4.2 缓存失效策略优化
**优先级**: 🔥 中  
**预估工时**: 2小时  

**实施步骤**:

##### 智能缓存失效系统
```typescript
// api/services/userCacheInvalidation.ts (新增文件)
import { userCache, statsCache } from '../lib/cacheInstances.js'
import { CACHE_PREFIXES } from '../config/cache.js'

export class UserCacheInvalidation {
  
  // 用户发布帖子后的缓存失效
  static async onPostCreated(userId: string) {
    const patterns = [
      `${CACHE_PREFIXES.USER}${userId}:posts:`,
      `${CACHE_PREFIXES.USER}${userId}:dashboard`,
      `${CACHE_PREFIXES.STATS}user:${userId}`
    ]
    
    await this.invalidateByPatterns(patterns)
  }
  
  // 用户参加活动后的缓存失效
  static async onActivityJoined(userId: string) {
    const patterns = [
      `${CACHE_PREFIXES.USER}${userId}:activities:`,
      `${CACHE_PREFIXES.USER}${userId}:dashboard`,
      `${CACHE_PREFIXES.STATS}user:${userId}`
    ]
    
    await this.invalidateByPatterns(patterns)
  }
  
  // 关注/取消关注的缓存失效
  static async onFollowChanged(followerId: string, followingId: string) {
    const patterns = [
      `${CACHE_PREFIXES.USER}${followerId}:following:`,
      `${CACHE_PREFIXES.USER}${followingId}:followers:`,
      `${CACHE_PREFIXES.STATS}user:${followerId}`,
      `${CACHE_PREFIXES.STATS}user:${followingId}`
    ]
    
    await this.invalidateByPatterns(patterns)
  }
  
  // 通知相关缓存失效
  static async onNotificationChanged(userId: string) {
    const patterns = [
      `${CACHE_PREFIXES.USER}${userId}:notifications:`,
      `${CACHE_PREFIXES.USER}${userId}:dashboard`
    ]
    
    await this.invalidateByPatterns(patterns)
  }
  
  // 按模式批量清理缓存
  private static async invalidateByPatterns(patterns: string[]) {
    try {
      for (const pattern of patterns) {
        // 从userCache清理
        const userKeys = userCache.keys().filter(key => key.includes(pattern))
        if (userKeys.length > 0) {
          await userCache.mdel(userKeys)
        }
        
        // 从statsCache清理
        const statsKeys = statsCache.keys().filter(key => key.includes(pattern))
        if (statsKeys.length > 0) {
          await statsCache.mdel(statsKeys)
        }
      }
      
      console.log(`缓存清理完成，模式: ${patterns.join(', ')}`)
    } catch (error) {
      console.error('缓存清理失败:', error)
    }
  }
}
```

##### 在相关API中集成智能失效
```typescript
// 在发布帖子的API中
router.post('/posts', asyncHandler(async (req, res) => {
  // ... 发布帖子逻辑 ...
  
  if (success) {
    // 智能缓存失效
    await UserCacheInvalidation.onPostCreated(userId)
  }
  
  // ... 返回响应 ...
}))

// 在参加活动的API中
router.post('/activities/:id/join', asyncHandler(async (req, res) => {
  // ... 参加活动逻辑 ...
  
  if (success) {
    await UserCacheInvalidation.onActivityJoined(userId)
  }
  
  // ... 返回响应 ...
}))
```

**验收标准**:
- [ ] 用户操作后相关缓存5秒内自动失效
- [ ] 缓存失效不影响API响应时间
- [ ] 支持级联清理相关缓存

---

## 📊 项目验收标准

### 整体性能目标
- [ ] **个人中心加载速度提升**: 70% (从平均800ms降至200ms)
- [ ] **缓存命中率**: 整体80%以上，核心模块85%以上  
- [ ] **API调用减少**: 60-75%
- [ ] **用户体验**: 页面切换更流畅，数据加载更快

### 各模块具体目标

#### 帖子管理模块
- [ ] 用户帖子列表查询: 300ms → 50ms
- [ ] 帖子统计查询: 400ms → 60ms
- [ ] 缓存命中率: 80%以上

#### 活动管理模块
- [ ] 活动列表查询: 400ms → 60ms  
- [ ] 参与活动查询: 350ms → 55ms
- [ ] 缓存命中率: 75%以上

#### 通知系统
- [ ] 通知列表查询: ∞ (模拟数据) → 100ms
- [ ] 通知实时性: 3分钟内
- [ ] 缓存命中率: 70%以上

#### 个人中心概览
- [ ] 概览页加载: 800ms → 150ms
- [ ] API调用减少: 6个 → 1个
- [ ] 数据聚合效率: 提升80%

---

## 🛠️ 实施时间安排

### 第一周 (核心数据缓存)
- **周一-周二**: 任务1.1-1.2 用户帖子和活动列表缓存 (6h)
- **周三**: 任务1.3 用户统计数据优化 (2h)
- **周四-周五**: 测试和优化核心缓存功能

### 第二周 (通知与社交功能)  
- **周一-周三**: 任务2.1 通知系统完整实现 (5h)
- **周四**: 任务3.1 社交关系缓存 (4h)
- **周五**: 集成测试和问题修复

### 第三周 (高级优化)
- **周一-周二**: 任务4.1 概览数据聚合缓存 (3h)  
- **周三**: 任务4.2 智能缓存失效优化 (2h)
- **周四**: 全面性能测试和调优
- **周五**: 用户体验测试和文档更新

---

## 🚨 风险评估和应对策略

### 技术风险
1. **通知系统复杂性**: 需要实时性和缓存平衡
2. **缓存一致性**: 社交关系变化的级联更新
3. **前端状态管理**: 多标签页数据同步

### 应对策略
1. **分层缓存**: 通知使用短TTL，统计数据使用长TTL
2. **智能失效**: 实施精确的缓存清理策略  
3. **状态同步**: 使用React Context和缓存状态管理

---

## 📈 成功指标监控

### 实时监控指标
- [ ] 个人中心各标签页响应时间
- [ ] 缓存命中率分析
- [ ] 用户操作后缓存失效准确性

### 用户体验指标
- [ ] 页面切换流畅度
- [ ] 数据加载等待时间  
- [ ] 缓存数据一致性检查

---

## 🎯 项目总结

这个前台个人中心缓存优化方案将显著提升用户体验：

1. **性能大幅提升**: 个人中心响应速度提升70%
2. **功能完善**: 从模拟通知到完整通知系统
3. **智能缓存**: 自动失效和数据一致性保证  
4. **用户体验**: 流畅的页面切换和快速的数据加载

通过3周的系统化实施，用户的个人中心将从基础功能升级为高性能、功能完善的用户管理平台！✨
