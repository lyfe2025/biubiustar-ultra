/**
 * æ‰¹é‡æ•°æ®æœåŠ¡çš„æ•°æ®è·å–å™¨
 * è´Ÿè´£å„ç§é¡µé¢å’Œç»„ä»¶çš„æ•°æ®è·å–é€»è¾‘
 */

import { 
  BatchRequest, 
  BatchResponse, 
  HomePageDataResult, 
  PostDetailDataResult, 
  ActivitiesPageDataResult,
  HomePageData,
  PostDetailData,
  ActivitiesPageData
} from './types';
import { CacheManager } from './CacheManager';
import { PerformanceMonitor } from './PerformanceMonitor';
import { FallbackHandler } from './FallbackHandler';
import { shortTermCache, defaultCache } from '../cacheService';
import { fallbackService, FallbackResult } from '../fallbackService';

export class DataFetchers {
  private cacheManager: CacheManager;
  private performanceMonitor: PerformanceMonitor;
  private fallbackHandler: FallbackHandler;

  constructor(
    cacheManager: CacheManager,
    performanceMonitor: PerformanceMonitor,
    fallbackHandler: FallbackHandler
  ) {
    this.cacheManager = cacheManager;
    this.performanceMonitor = performanceMonitor;
    this.fallbackHandler = fallbackHandler;
  }

  /**
   * è·å–é¦–é¡µæ•°æ®ï¼ˆå¸–å­ + æ´»åŠ¨ï¼‰
   * @param options é¦–é¡µæ•°æ®é€‰é¡¹
   * @returns é¦–é¡µæ•°æ®ç»“æœ
   */
  async getHomePageData(options: {
    postsLimit?: number;
    activitiesLimit?: number;
  } = {}): Promise<HomePageDataResult> {
    const cacheKey = `home-page-data-${options.postsLimit || 3}-${options.activitiesLimit || 2}`;
    
    // æ£€æŸ¥ç¼“å­˜
    const cached = shortTermCache.get<HomePageData>(cacheKey);
    if (cached) {
      console.log('ğŸ¯ ä½¿ç”¨ç¼“å­˜çš„é¦–é¡µæ•°æ®');
      return cached as HomePageDataResult;
    }

    const startTime = performance.now();
    
    // ä¸»è¦æ“ä½œï¼šæ‰¹é‡API
    const primaryOperation = async (): Promise<HomePageData> => {
      console.log('ğŸš€ å¼€å§‹æ‰¹é‡è·å–é¦–é¡µæ•°æ®');
      const response = await fetch('/api/batch/home-data');
      if (!response.ok) {
        throw new Error(`æ‰¹é‡APIå¤±è´¥: ${response.status}`);
      }
      return await response.json();
    };
    
    // é™çº§æ“ä½œï¼šç‹¬ç«‹APIè°ƒç”¨
    const fallbackOperation = async (): Promise<HomePageData> => {
      console.log('ğŸ”„ é™çº§åˆ°ç‹¬ç«‹APIè°ƒç”¨');
      const [postsResponse, activitiesResponse] = await Promise.all([
        fetch('/api/posts?page=1&limit=3'),
        fetch('/api/activities/upcoming?limit=2')
      ]);
      
      if (!postsResponse.ok || !activitiesResponse.ok) {
        throw new Error('ç‹¬ç«‹APIè°ƒç”¨å¤±è´¥');
      }
      
      const [postsData, activitiesData] = await Promise.all([
        postsResponse.json(),
        activitiesResponse.json()
      ]);
      
      return {
        posts: postsData.posts || postsData,
        activities: activitiesData
      };
    };

    // ä½¿ç”¨é™çº§æœåŠ¡æ‰§è¡Œæ“ä½œ
    const result: FallbackResult<HomePageData> = await fallbackService.executeWithFallback(
      primaryOperation,
      fallbackOperation,
      {
        maxRetries: 1,
        retryDelay: 500,
        timeout: 8000
      }
    );
    
    // è®°å½•é™çº§äº‹ä»¶
    fallbackService.logFallbackEvent('getHomePageData', result);
    
    if (result.success && result.data) {
      const endTime = performance.now();
      console.log(`âœ… é¦–é¡µæ•°æ®è·å–æˆåŠŸï¼Œè€—æ—¶: ${endTime - startTime}msï¼Œä½¿ç”¨é™çº§: ${result.usedFallback}`);
      
      // ç¼“å­˜ç»“æœï¼ˆé™çº§æ•°æ®ç¼“å­˜æ—¶é—´è¾ƒçŸ­ï¼‰
      const cacheTime = result.usedFallback ? 30 * 1000 : 2 * 60 * 1000;
      shortTermCache.set(cacheKey, result.data, { ttl: cacheTime });
      console.log('ğŸ’¾ é¦–é¡µæ•°æ®å·²ç¼“å­˜');
      
      return result.data;
    } else {
      const endTime = performance.now();
      console.error(`âŒ é¦–é¡µæ•°æ®è·å–å¤±è´¥ï¼Œè€—æ—¶: ${endTime - startTime}ms`);
      throw result.error || new Error('é¦–é¡µæ•°æ®è·å–å¤±è´¥');
    }
  }

  /**
   * æ‰¹é‡è·å–é¦–é¡µæ•°æ®ï¼ˆæ—§ç‰ˆæœ¬å…¼å®¹ï¼‰
   * @param options é¦–é¡µæ•°æ®é€‰é¡¹
   * @returns é¦–é¡µæ•°æ®ç»“æœ
   */
  async getHomePageDataLegacy(options: {
    postsLimit?: number;
    activitiesLimit?: number;
  } = {}): Promise<{
    posts: any[];
    activities: any[];
    errors?: any;
  }> {
    const metricName = 'home_page_data_legacy';
    const startTime = Date.now();
    const requestId = this.performanceMonitor.generateRequestId();
    
    const cacheKey = `home-data-${options.postsLimit || 3}-${options.activitiesLimit || 2}`;
    
    // æ£€æŸ¥ç¼“å­˜
    const cached = this.cacheManager.getFromCache(cacheKey);
    if (cached) {
      this.performanceMonitor.recordMetrics({
        requestId: startTime.toString(),
        operation: metricName,
        method: 'GET',
        startTime: startTime,
        duration: 0,
        success: true,
        cacheHit: true,
        batchSize: 1,
        errors: []
      });
      const cachedData = cached as HomePageData;
       return {
         posts: cachedData.posts || [],
         activities: cachedData.activities || [],
         errors: {}
       };
    }

    const requestStartTime = Date.now();
    
    try {
      // ä½¿ç”¨æ–°çš„æ‰¹é‡APIç«¯ç‚¹
      const requests: BatchRequest[] = [
        {
          id: 'posts',
          type: 'posts',
          endpoint: '/api/posts',
          params: { limit: options.postsLimit || 3 }
        },
        {
          id: 'activities',
          type: 'activities',
          endpoint: '/api/activities/upcoming',
          params: { upcoming: true, limit: options.activitiesLimit || 2 }
        }
      ];
      
      // è¿™é‡Œéœ€è¦è°ƒç”¨æ‰¹é‡å¤„ç†å™¨çš„æ–¹æ³•
      // const batchResults = await this.batchProcessor.batchFetch(requests, { useCache: false });
      
      const result: HomePageDataResult = {
        posts: [],
        activities: [],
        errors: {}
      };
      
      // å¤„ç†æ‰¹é‡ç»“æœ
      // batchResults.forEach(response => {
      //   if (response.id === 'posts') {
      //     if (response.error) {
      //       result.errors.posts = response.error;
      //     } else {
      //       result.posts = response.data || [];
      //     }
      //   } else if (response.id === 'activities') {
      //     if (response.error) {
      //       result.errors.activities = response.error;
      //     } else {
      //       result.activities = response.data || [];
      //     }
      //   }
      // });

      // ç¼“å­˜ç»“æœ
      this.cacheManager.setCache(cacheKey, result, 300000);

      this.performanceMonitor.recordMetrics({
        requestId: startTime.toString(),
        operation: metricName,
        method: 'GET',
        startTime: startTime,
        duration: Date.now() - requestStartTime,
        success: true,
        cacheHit: false,
        batchSize: 2,
        errors: []
      });
      
      return result;

    } catch (error) {
      this.performanceMonitor.recordMetrics({
        requestId: startTime.toString(),
        operation: metricName,
        method: 'GET',
        startTime: startTime,
        duration: Date.now() - requestStartTime,
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        cacheHit: false,
        batchSize: 2,
        errors: [error instanceof Error ? error.message : 'Unknown error']
      });
      
      // é™çº§åˆ°å•ç‹¬è°ƒç”¨
      return {
        posts: [],
        activities: [],
        errors: { general: error instanceof Error ? error.message : 'Unknown error' }
      };
    }
  }

  /**
   * è·å–å¸–å­è¯¦æƒ…é¡µæ•°æ®ï¼ˆå¸–å­è¯¦æƒ… + è¯„è®º + ç‚¹èµçŠ¶æ€ + åˆ†ç±»ï¼‰
   * @param postId å¸–å­ID
   * @param userId ç”¨æˆ·IDï¼ˆå¯é€‰ï¼‰
   * @returns å¸–å­è¯¦æƒ…æ•°æ®ç»“æœ
   */
  async getPostDetailData(postId: string, userId?: string): Promise<PostDetailDataResult> {
    const cacheKey = `post-detail-${postId}-${userId || 'anonymous'}`;
    
    // æ£€æŸ¥ç¼“å­˜
    const cached = shortTermCache.get<PostDetailData>(cacheKey);
    if (cached) {
      console.log('ğŸ¯ ä½¿ç”¨ç¼“å­˜çš„å¸–å­è¯¦æƒ…æ•°æ®');
      return cached as PostDetailDataResult;
    }

    const startTime = performance.now();
    
    // ä¸»è¦æ“ä½œï¼šæ‰¹é‡API
    const primaryOperation = async (): Promise<PostDetailData> => {
      console.log('ğŸš€ å¼€å§‹æ‰¹é‡è·å–å¸–å­è¯¦æƒ…æ•°æ®');
      const response = await fetch(`/api/batch/post-detail/${postId}?userId=${userId || ''}`);
      if (!response.ok) {
        throw new Error(`æ‰¹é‡APIå¤±è´¥: ${response.status}`);
      }
      return await response.json();
    };
    
    // é™çº§æ“ä½œï¼šç‹¬ç«‹APIè°ƒç”¨
    const fallbackOperation = async (): Promise<PostDetailData> => {
      console.log('ğŸ”„ é™çº§åˆ°ç‹¬ç«‹APIè°ƒç”¨');
      const requests = [
        fetch(`/api/posts/${postId}`),
        fetch(`/api/posts/${postId}/comments`),
        fetch(`/api/categories/content`)
      ];
      
      if (userId) {
        requests.push(fetch(`/api/posts/${postId}/likes/${userId}`));
      }
      
      const responses = await Promise.all(requests);
      
      // æ£€æŸ¥æ‰€æœ‰å“åº”æ˜¯å¦æˆåŠŸ
      for (const response of responses) {
        if (!response.ok) {
          throw new Error(`APIè°ƒç”¨å¤±è´¥: ${response.status}`);
        }
      }
      
      const [postData, commentsData, categoriesData, likeData] = await Promise.all(
        responses.map(r => r.json())
      );
      
      return {
        post: postData,
        comments: commentsData,
        categories: categoriesData,
        isLiked: likeData?.isLiked || false,
        likesCount: postData?.likes_count || 0
      };
    };

    // ä½¿ç”¨é™çº§æœåŠ¡æ‰§è¡Œæ“ä½œ
    const result: FallbackResult<PostDetailData> = await fallbackService.executeWithFallback(
      primaryOperation,
      fallbackOperation,
      {
        maxRetries: 1,
        retryDelay: 500,
        timeout: 10000
      }
    );
    
    // è®°å½•é™çº§äº‹ä»¶
    fallbackService.logFallbackEvent('getPostDetailData', result);
    
    if (result.success && result.data) {
      const endTime = performance.now();
      console.log(`âœ… å¸–å­è¯¦æƒ…æ•°æ®è·å–æˆåŠŸï¼Œè€—æ—¶: ${endTime - startTime}msï¼Œä½¿ç”¨é™çº§: ${result.usedFallback}`);
      
      // ç¼“å­˜ç»“æœï¼ˆé™çº§æ•°æ®ç¼“å­˜æ—¶é—´è¾ƒçŸ­ï¼‰
      const cacheTime = result.usedFallback ? 60 * 1000 : 3 * 60 * 1000;
      shortTermCache.set(cacheKey, result.data, { ttl: cacheTime });
      console.log('ğŸ’¾ å¸–å­è¯¦æƒ…æ•°æ®å·²ç¼“å­˜');
      
      return result.data;
    } else {
      const endTime = performance.now();
      console.error(`âŒ å¸–å­è¯¦æƒ…æ•°æ®è·å–å¤±è´¥ï¼Œè€—æ—¶: ${endTime - startTime}ms`);
      throw result.error || new Error('å¸–å­è¯¦æƒ…æ•°æ®è·å–å¤±è´¥');
    }
  }

  /**
   * æ‰¹é‡è·å–å¸–å­è¯¦æƒ…é¡µæ•°æ®ï¼ˆæ—§ç‰ˆæœ¬å…¼å®¹ï¼‰
   * @param postId å¸–å­ID
   * @param userId ç”¨æˆ·IDï¼ˆå¯é€‰ï¼‰
   * @returns å¸–å­è¯¦æƒ…æ•°æ®ç»“æœ
   */
  async getPostDetailDataLegacy(postId: string, userId?: string): Promise<{
    post: any;
    comments: any[];
    likesCount: number;
    isLiked: boolean;
    categories: any[];
    errors?: any;
  }> {
    const metricName = 'post_detail_data_legacy';
    const startTime = Date.now();
    const requestId = this.performanceMonitor.generateRequestId();
    
    const cacheKey = `post-detail-${postId}-${userId || 'anonymous'}`;
    
    // æ£€æŸ¥ç¼“å­˜
    const cached = this.cacheManager.getFromCache(cacheKey);
    if (cached) {
      this.performanceMonitor.recordMetrics({
        requestId: requestId,
        requestType: 'single',
        timestamp: Date.now(),
        operation: metricName,
        method: 'GET',
        startTime: startTime,
        endTime: Date.now(),
        duration: 0,
        batchSize: 1,
        success: true,
        cacheHit: true
      });
      return cached as PostDetailDataResult;
    }

    const requestStartTime = Date.now();

    try {
      // ä½¿ç”¨æ–°çš„æ‰¹é‡APIç«¯ç‚¹
      const requests: BatchRequest[] = [
        {
          id: 'post-details',
          type: 'post_details',
          endpoint: `/api/posts/${postId}`,
          params: { postId, userId }
        },
        {
          id: 'comments',
          type: 'comments',
          endpoint: `/api/posts/${postId}/comments`,
          params: { postId }
        },
        {
          id: 'categories',
          type: 'categories',
          endpoint: '/api/categories/content',
          params: { type: 'content' }
        }
      ];
      
      // è¿™é‡Œéœ€è¦è°ƒç”¨æ‰¹é‡å¤„ç†å™¨çš„æ–¹æ³•
      // const batchResults = await this.batchProcessor.batchFetch(requests, { useCache: false });
      
      const result: PostDetailDataResult = {
        post: null,
        comments: [],
        likesCount: 0,
        isLiked: false,
        categories: [],
        errors: {}
      };
      
      // å¤„ç†æ‰¹é‡ç»“æœ
      // batchResults.forEach(response => {
      //   if (response.id === 'post-details') {
      //     if (response.error) {
      //       result.errors.post = response.error;
      //     } else {
      //       result.post = response.data?.post || null;
      //       result.isLiked = response.data?.isLiked || false;
      //       result.likesCount = response.data?.post?.likes_count || 0;
      //     }
      //   } else if (response.id === 'comments') {
      //     if (response.error) {
      //       result.errors.comments = response.error;
      //     } else {
      //       result.comments = response.data || [];
      //     }
      //   } else if (response.id === 'categories') {
      //     if (response.error) {
      //       result.errors.categories = response.error;
      //     } else {
      //       result.categories = response.data || [];
      //     }
      //   }
      // });

      // ç¼“å­˜ç»“æœ
      this.cacheManager.setCache(cacheKey, result, 300000);

      this.performanceMonitor.recordMetrics({
        requestId: `home-${requestStartTime}`,
        requestType: 'batch',
        timestamp: requestStartTime,
        operation: metricName,
        method: 'GET',
        startTime: requestStartTime,
        endTime: Date.now(),
        duration: Date.now() - requestStartTime,
        batchSize: 2, // posts + activities
        success: true,
        cacheHit: false
      });
      
      return result;

    } catch (error) {
      this.performanceMonitor.recordMetrics({
        requestId: `home-${requestStartTime}`,
        requestType: 'batch',
        timestamp: requestStartTime,
        operation: metricName,
        method: 'GET',
        startTime: requestStartTime,
        endTime: Date.now(),
        duration: Date.now() - requestStartTime,
        batchSize: 2, // posts + activities
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        cacheHit: false
      });
      
      // é™çº§åˆ°å•ç‹¬è°ƒç”¨
      return this.fallbackHandler.fallbackToSeparatePostDetailCalls(postId, userId);
    }
  }

  /**
   * è·å–æ´»åŠ¨é¡µé¢æ•°æ®ï¼ˆæ´»åŠ¨åˆ—è¡¨ + åˆ†ç±»ï¼‰
   * @param options æ´»åŠ¨é¡µé¢é€‰é¡¹
   * @returns æ´»åŠ¨é¡µé¢æ•°æ®ç»“æœ
   */
  async getActivitiesPageData(options: {
    page?: number;
    limit?: number;
  } = {}): Promise<ActivitiesPageDataResult> {
    const cacheKey = `activities-page-data-${options.page || 1}-${options.limit || 10}`;
    
    // æ£€æŸ¥ç¼“å­˜
    const cached = defaultCache.get<ActivitiesPageData>(cacheKey);
    if (cached) {
      console.log('ğŸ¯ ä½¿ç”¨ç¼“å­˜çš„æ´»åŠ¨é¡µé¢æ•°æ®');
      return cached as ActivitiesPageDataResult;
    }

    const startTime = performance.now();
    
    // ä¸»è¦æ“ä½œï¼šæ‰¹é‡API
    const primaryOperation = async (): Promise<ActivitiesPageData> => {
      console.log('ğŸš€ å¼€å§‹æ‰¹é‡è·å–æ´»åŠ¨é¡µé¢æ•°æ®');
      const response = await fetch('/api/batch/activities-data');
      if (!response.ok) {
        throw new Error(`æ‰¹é‡APIå¤±è´¥: ${response.status}`);
      }
      return await response.json();
    };
    
    // é™çº§æ“ä½œï¼šç‹¬ç«‹APIè°ƒç”¨
    const fallbackOperation = async (): Promise<ActivitiesPageData> => {
      console.log('ğŸ”„ é™çº§åˆ°ç‹¬ç«‹APIè°ƒç”¨');
      const [activitiesResponse, categoriesResponse] = await Promise.all([
        fetch('/api/activities'),
        fetch('/api/categories/activities')
      ]);
      
      if (!activitiesResponse.ok || !categoriesResponse.ok) {
        throw new Error('ç‹¬ç«‹APIè°ƒç”¨å¤±è´¥');
      }
      
      const [activitiesData, categoriesData] = await Promise.all([
        activitiesResponse.json(),
        categoriesResponse.json()
      ]);
      
      return {
        activities: activitiesData,
        categories: categoriesData
      };
    };

    // ä½¿ç”¨é™çº§æœåŠ¡æ‰§è¡Œæ“ä½œ
    const result: FallbackResult<ActivitiesPageData> = await fallbackService.executeWithFallback(
      primaryOperation,
      fallbackOperation,
      {
        maxRetries: 1,
        retryDelay: 500,
        timeout: 8000
      }
    );
    
    // è®°å½•é™çº§äº‹ä»¶
    fallbackService.logFallbackEvent('getActivitiesPageData', result);
    
    if (result.success && result.data) {
      const endTime = performance.now();
      console.log(`âœ… æ´»åŠ¨é¡µé¢æ•°æ®è·å–æˆåŠŸï¼Œè€—æ—¶: ${endTime - startTime}msï¼Œä½¿ç”¨é™çº§: ${result.usedFallback}`);
      
      // ç¼“å­˜ç»“æœï¼ˆé™çº§æ•°æ®ç¼“å­˜æ—¶é—´è¾ƒçŸ­ï¼‰
      const cacheTime = result.usedFallback ? 2 * 60 * 1000 : 5 * 60 * 1000;
      defaultCache.set(cacheKey, result.data, { ttl: cacheTime });
      console.log('ğŸ’¾ æ´»åŠ¨é¡µé¢æ•°æ®å·²ç¼“å­˜');
      
      return result.data;
    } else {
      const endTime = performance.now();
      console.error(`âŒ æ´»åŠ¨é¡µé¢æ•°æ®è·å–å¤±è´¥ï¼Œè€—æ—¶: ${endTime - startTime}ms`);
      throw result.error || new Error('æ´»åŠ¨é¡µé¢æ•°æ®è·å–å¤±è´¥');
    }
  }

  /**
   * æ‰¹é‡è·å–æ´»åŠ¨é¡µé¢æ•°æ®ï¼ˆæ—§ç‰ˆæœ¬å…¼å®¹ï¼‰
   * @param options æ´»åŠ¨é¡µé¢é€‰é¡¹
   * @returns æ´»åŠ¨é¡µé¢æ•°æ®ç»“æœ
   */
  async getActivitiesPageDataLegacy(options: {
    page?: number;
    limit?: number;
  } = {}): Promise<{
    activities: any[];
    categories: any[];
    errors?: any;
  }> {
    const metricName = 'activities_page_data_legacy';
    const startTime = Date.now();
    const requestId = this.performanceMonitor.generateRequestId();
    
    const cacheKey = `activities-data-${options.page || 1}-${options.limit || 10}`;
    
    // æ£€æŸ¥ç¼“å­˜
    const cached = this.cacheManager.getFromCache(cacheKey);
    if (cached) {
      this.performanceMonitor.recordMetrics({
        requestId: requestId,
        requestType: 'single',
        timestamp: Date.now(),
        operation: metricName,
        method: 'GET',
        startTime: startTime,
        endTime: Date.now(),
        duration: 0,
        batchSize: 1,
        success: true,
        cacheHit: true
      });
      return cached as ActivitiesPageDataResult;
    }

    const requestStartTime = Date.now();

    try {
      // ä½¿ç”¨æ–°çš„æ‰¹é‡APIç«¯ç‚¹
      const requests: BatchRequest[] = [
        {
          id: 'activities',
          type: 'activities',
          endpoint: '/api/activities',
          params: { page: options.page || 1, limit: options.limit || 10 }
        },
        {
          id: 'categories',
          type: 'categories',
          endpoint: '/api/categories/activities',
          params: { type: 'activity' }
        }
      ];
      
      // è¿™é‡Œéœ€è¦è°ƒç”¨æ‰¹é‡å¤„ç†å™¨çš„æ–¹æ³•
      // const batchResults = await this.batchProcessor.batchFetch(requests, { useCache: false });
      
      const result: ActivitiesPageDataResult = {
        activities: [],
        categories: [],
        errors: {}
      };
      
      // å¤„ç†æ‰¹é‡ç»“æœ
      // batchResults.forEach(response => {
      //   if (response.id === 'activities') {
      //     if (response.error) {
      //       result.errors.activities = response.error;
      //     } else {
      //       result.activities = response.data || [];
      //     }
      //   } else if (response.id === 'categories') {
      //     if (response.error) {
      //       result.errors.categories = response.error;
      //     } else {
      //       result.categories = response.data || [];
      //     }
      //   }
      // });

      // ç¼“å­˜ç»“æœ
      this.cacheManager.setCache(cacheKey, result, 300000);

      this.performanceMonitor.recordMetrics({
        requestId: `activities-${requestStartTime}`,
        requestType: 'batch',
        timestamp: requestStartTime,
        operation: metricName,
        method: 'GET',
        startTime: requestStartTime,
        endTime: Date.now(),
        duration: Date.now() - requestStartTime,
        batchSize: 2, // activities + categories
        success: true,
        cacheHit: false
      });
      
      return result;

    } catch (error) {
      this.performanceMonitor.recordMetrics({
        requestId: `activities-${requestStartTime}`,
        requestType: 'batch',
        timestamp: requestStartTime,
        operation: metricName,
        method: 'GET',
        startTime: requestStartTime,
        endTime: Date.now(),
        duration: Date.now() - requestStartTime,
        batchSize: 2, // activities + categories
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        cacheHit: false
      });
      
      // é™çº§åˆ°å•ç‹¬è°ƒç”¨
      return this.fallbackHandler.fallbackToSeparateActivitiesCalls(options);
    }
  }

  /**
   * é€šç”¨æ•°æ®è·å–æ–¹æ³•
   * @param endpoint APIç«¯ç‚¹
   * @param options è¯·æ±‚é€‰é¡¹
   * @returns æ•°æ®ç»“æœ
   */
  async fetchData<T>(endpoint: string, options?: {
    method?: string;
    headers?: Record<string, string>;
    body?: any;
    cache?: boolean;
    cacheKey?: string;
    cacheTtl?: number;
  }): Promise<T> {
    const {
      method = 'GET',
      headers = {},
      body,
      cache = true,
      cacheKey,
      cacheTtl = 5 * 60 * 1000 // 5åˆ†é’Ÿé»˜è®¤ç¼“å­˜
    } = options || {};

    const finalCacheKey = cacheKey || `fetch-${endpoint}-${JSON.stringify(options)}`;

    // æ£€æŸ¥ç¼“å­˜
    if (cache) {
      const cached = this.cacheManager.getFromCache(finalCacheKey);
      if (cached) {
        console.log(`ğŸ¯ ä½¿ç”¨ç¼“å­˜æ•°æ®: ${endpoint}`);
        return cached as T;
      }
    }

    const startTime = performance.now();
    
    try {
      console.log(`ğŸš€ å¼€å§‹è·å–æ•°æ®: ${endpoint}`);
      
      const response = await fetch(endpoint, {
        method,
        headers: {
          'Content-Type': 'application/json',
          ...headers
        },
        body: body ? JSON.stringify(body) : undefined
      });

      if (!response.ok) {
        throw new Error(`APIè°ƒç”¨å¤±è´¥: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const endTime = performance.now();
      
      console.log(`âœ… æ•°æ®è·å–æˆåŠŸ: ${endpoint}ï¼Œè€—æ—¶: ${endTime - startTime}ms`);

      // ç¼“å­˜ç»“æœ
      if (cache) {
        this.cacheManager.setCache(finalCacheKey, data, cacheTtl);
        console.log(`ğŸ’¾ æ•°æ®å·²ç¼“å­˜: ${endpoint}`);
      }

      return data;
    } catch (error) {
      const endTime = performance.now();
      console.error(`âŒ æ•°æ®è·å–å¤±è´¥: ${endpoint}ï¼Œè€—æ—¶: ${endTime - startTime}ms`, error);
      throw error;
    }
  }

  /**
   * æ‰¹é‡æ•°æ®è·å–æ–¹æ³•
   * @param requests æ‰¹é‡è¯·æ±‚æ•°ç»„
   * @param options æ‰¹é‡è¯·æ±‚é€‰é¡¹
   * @returns æ‰¹é‡å“åº”æ•°ç»„
   */
  async batchFetchData(requests: {
    id: string;
    endpoint: string;
    options?: any;
  }[], options?: {
    useCache?: boolean;
    parallel?: boolean;
    timeout?: number;
  }): Promise<{ id: string; data?: any; error?: string }[]> {
    const {
      useCache = true,
      parallel = true,
      timeout = 10000
    } = options || {};

    const results: { id: string; data?: any; error?: string }[] = [];

    if (parallel) {
      // å¹¶è¡Œæ‰§è¡Œ
      const promises = requests.map(async (request) => {
        try {
          const data = await Promise.race([
            this.fetchData(request.endpoint, {
              ...request.options,
              cache: useCache
            }),
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error('è¯·æ±‚è¶…æ—¶')), timeout)
            )
          ]);
          return { id: request.id, data };
        } catch (error) {
          return {
            id: request.id,
            error: error instanceof Error ? error.message : String(error)
          };
        }
      });

      return await Promise.all(promises);
    } else {
      // ä¸²è¡Œæ‰§è¡Œ
      for (const request of requests) {
        try {
          const data = await this.fetchData(request.endpoint, {
            ...request.options,
            cache: useCache
          });
          results.push({ id: request.id, data });
        } catch (error) {
          results.push({
            id: request.id,
            error: error instanceof Error ? error.message : String(error)
          });
        }
      }
      return results;
    }
  }
}